<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>关于reuseport那些事儿 | 秋月春风等闲度,暮去朝来颜色故</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于reuseport那些事儿</h1><a id="logo" href="/.">秋月春风等闲度,暮去朝来颜色故</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于reuseport那些事儿</h1><div class="post-meta">May 4, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>nginx开启reuse port后，据说benchmark能跑很多。那么为啥nginx能在reuseport开启的情况下性能提升不少呢？nginx使用reuseport需要注意哪些问题呢？</p>
<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><p>reuseport是在nginx 1.9.1里提供了支持，官方更是提供了篇幅介绍reuseport带来的好处，主要是benchmark的提升。</p>
<p>具体详情可见：<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></p>
<p>我们这里想介绍一下，在nginx里是如何使用reuseport功能带来性能提升的</p>
<h2 id="2-reuseport的原理"><a href="#2-reuseport的原理" class="headerlink" title="2.reuseport的原理"></a>2.reuseport的原理</h2><p>在3.9内核以前，为了支持多进程模型像haproxy，nginx等，大家不约而同的采用的fork的做法，即在父进程里，监听一个IP+port。<br>然后fork出N个子进程，子进程天然继承了父进程的listen socket的句柄，即可以执行accept操作了。</p>
<p><img src="fork_share.png" alt=""></p>
<p>但因为是fork出来的，所以在kernel里，仍然是一个句柄，多个进程执行accept还是有竞争关系，所以nginx需要配置accept_mutex这样的开关</p>
<p>当开启reuseport后，每个监听地址将会有多个句柄，具体来说是一个worker一个，这样每个worker关心的listen socket就独立开了，自己搞定自己的事，避免了多进程的竞争。</p>
<p><img src="reuseport_share.png" alt=""></p>
<h2 id="3-reuseport在nginx的使用"><a href="#3-reuseport在nginx的使用" class="headerlink" title="3.reuseport在nginx的使用"></a>3.reuseport在nginx的使用</h2><p>通常情况下，使用reuseaddr都是启动多个进程，大家绑定相同的IP和port，然后就可以无限发挥reuseport的特性了。<br>但nginx毕竟还是采用了fork的模型。那么个是如何充分利用reuseport的呢？看代码吧。<br>在ngx_clone_listening里有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (n = 1; n &lt; ccf-&gt;worker_processes; n++) &#123;    </span><br><span class="line"></span><br><span class="line">    /* create a socket for each worker process */</span><br><span class="line"></span><br><span class="line">    ls = ngx_array_push(&amp;cf-&gt;cycle-&gt;listening);</span><br><span class="line">    if (ls == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ls = ols;</span><br><span class="line">    ls-&gt;worker = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(注意是从1开始的，因为master会创建一个worker是0的listener)<br>也就是解析完配置文件后，会根据worker的个数fork出来多个listener对象，统一扔到数组里，那么啥时候打开监听呢?</p>
<p>ngx_init_cycle<br>—&gt;ngx_open_listening_sockets<br>    —&gt;bind<br>    —&gt;listen</p>
<p>因为设置了reuseport，所以数组里塞进去的ip port重复的listener可以创建好。<br>比如有8个worker，会创建出8个listen socket。</p>
<p>那么剩下来的问题就是，如何让一个listen socket和worker进程绑定。</p>
<p>那么就看ngx_event_process_init，worker进程初始化event模块的时候，会调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (NGX_HAVE_REUSEPORT)</span><br><span class="line">       if (ls[i].reuseport &amp;&amp; ls[i].worker != ngx_worker) &#123;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里可以看出，我只把自己worker对应的listen socket加入到epoll里去。</p>
<h2 id="4-reuseport在nginx使用中遇到的问题"><a href="#4-reuseport在nginx使用中遇到的问题" class="headerlink" title="4.reuseport在nginx使用中遇到的问题"></a>4.reuseport在nginx使用中遇到的问题</h2><p>先说现象：<br>nginx从reuseport升级为非reuseport，以及从多worker升级为少worker都会有大量性能下降。<br>这里还是需要介绍一下reuseport的升级的流程，好trick。</p>
<p>升级的时候，也就是-USR2的时候，old maste启动新master的时候，会把所有listen socket的句柄们放在新进程的环境变量里。如果reuseport，举监听80端口为例，如果开启了4个worker，那么环境变量则存了4个句柄，格式为<br>句柄id1；句柄id2；句柄id3；句柄id4。<br>新的master启动后会把这个4个句柄读出来，注意，这4个句柄在新进程里也是合法的，然后调用各种syscall获得这个句柄的信息</p>
<ul>
<li>ls[i].sockaddr (调用getsockname())</li>
<li>ls[i].addr_text_max_len</li>
<li>ls[i].addr_text</li>
<li>ls[i].backlog</li>
<li>ls[i].rcvbuf (调用getsockopt())</li>
<li>ls[i].sndbuf (调用getsockopt())</li>
<li>ls[i].accept_filter</li>
<li>ls[i].deferred_accept</li>
</ul>
<p>这个信息是放在old_cycle里的，然后加载配置文件，配置文件里也依然会监听80端口，这时新的cycle的listening数组里会有一个ngx_listening_t,但是在ngx_http_optimize_servers里会间接调用ngx_clone_listening，来clone出 worker个数的listen句柄，但这时候因为还没有调用listen函数，所以ls[i]的fd是空，肯定不会走后面的listen函数的，因为环境变量已经把老的句柄传递过来了，直接复用即可，而且如果不复用，重新listen的话会出问题的，因为老的句柄在内核有queue，确没人accept。<br>那么是哪里为新的ngx_listening_t赋值的呢？就是在init_cycle的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (n = 0; n &lt; cycle-&gt;listening.nelts; n++) &#123;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; old_cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line">        if (ls[i].ignore) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ls[i].remain) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ls[i].type != nls[n].type) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,</span><br><span class="line">                             ls[i].sockaddr, ls[i].socklen, 1)</span><br><span class="line">            == NGX_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            nls[n].fd = ls[i].fd;</span><br><span class="line">            nls[n].previous = &amp;ls[i];</span><br><span class="line">            ls[i].remain = 1;</span><br><span class="line"></span><br><span class="line">            if (ls[i].backlog != nls[n].backlog) &#123;</span><br><span class="line">                nls[n].listen = 1;</span><br><span class="line">            &#125;</span><br><span class="line">...................</span><br></pre></td></tr></table></figure><br>对比新的cycle和旧的cycle，如果监听的地址一样，就拿来复用，已经复用的remain会置为1，下一个相同地址的就不会复用了。比如老的cycle里因为reuseport，一个ip+80，开启了4个 listen句柄，新的也开启4个listen结构，在上面的二层循环里，就一次把这个4个句柄赋值给新的 ngx_listening_t的fd。</p>
<p>这里的remain名字起的真是烂啊，我觉得叫copied/inherited都可以。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><p>reuseport功能会给nginx的性能带来很大的提升。但是升级的时候由于老的master的延迟退出，会导致在老的master退出之前，性能骤降，这和本来的on the fly upgrade 风格实在是落差不小。<br>也许是我理解有误，知道的小伙伴可以mail我。qzzhou$126.com</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://abonege.github.io/2017/05/04/nginx与reuseport/" data-id="cjq7qe7du000n4jlo9hojf471" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/2017/05/04/socket编程的内核实现/" class="pre">socket编程的内核实现</a><a href="/2017/01/20/RSA加密/" class="next">RSA加密</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://abonege.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/neutron/" style="font-size: 15px;">neutron</a> <a href="/tags/安全组/" style="font-size: 15px;">安全组</a> <a href="/tags/RSA加密/" style="font-size: 15px;">RSA加密</a> <a href="/tags/openssl/" style="font-size: 15px;">openssl</a> <a href="/tags/SSL/" style="font-size: 15px;">SSL</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/CC防护，nginx，封禁/" style="font-size: 15px;">CC防护，nginx，封禁</a> <a href="/tags/hyperscan/" style="font-size: 15px;">hyperscan</a> <a href="/tags/intel/" style="font-size: 15px;">intel</a> <a href="/tags/flow-table/" style="font-size: 15px;">flow-table</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/upstream/" style="font-size: 15px;">upstream</a> <a href="/tags/resolve/" style="font-size: 15px;">resolve</a> <a href="/tags/hyperscan编译/" style="font-size: 15px;">hyperscan编译</a> <a href="/tags/ovs/" style="font-size: 15px;">ovs</a> <a href="/tags/openvswitch/" style="font-size: 15px;">openvswitch</a> <a href="/tags/hexo使用/" style="font-size: 15px;">hexo使用</a> <a href="/tags/字节序/" style="font-size: 15px;">字节序</a> <a href="/tags/网络字节序，主机字节序/" style="font-size: 15px;">网络字节序，主机字节序</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/26/理解字节序/">理解字节序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/14/a-out的幕后/">a.out的幕后</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/RSA算法证明/">RSA算法证明</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/05/SSL基础知识总结/">SSL基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/nginx实现动态resolve的思路/">nginx实现动态resolve的思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/nginx上支持手工封禁请求的的思路/">nginx上支持手工封禁请求的的思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/hyperscan使用/">hyperscan使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/关于编译hyperscan/">关于编译hyperscan</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/nginx的配置管理/">nginx的配置管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/openssl签发证书/">openssl签发证书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://baidjia.baidu.com" title="百度百家" target="_blank">百度百家</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">秋月春风等闲度,暮去朝来颜色故.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>