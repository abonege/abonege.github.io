<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>秋月春风等闲度,暮去朝来颜色故</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="秋月春风等闲度,暮去朝来颜色故">
<meta property="og:url" content="http://abonege.github.io/index.html">
<meta property="og:site_name" content="秋月春风等闲度,暮去朝来颜色故">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋月春风等闲度,暮去朝来颜色故">
  
    <link rel="alternate" href="/atom.xml" title="秋月春风等闲度,暮去朝来颜色故" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">秋月春风等闲度,暮去朝来颜色故</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://abonege.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-理解字节序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/26/理解字节序/" class="article-date">
  <time datetime="2018-04-26T09:23:23.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/26/理解字节序/">理解字节序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>估计很多人和我一样，在debug过程中见到字节序就头大，比如wireshark里看到的是0x04d5表示一个长度，这个长度到底是多少呢？还比如 IP部分是 01020304，这到底是1.2.3.4还是4.3.2.1呢？</p>
<h2 id="分清字节序"><a href="#分清字节序" class="headerlink" title="分清字节序"></a>分清字节序</h2><p>肯定是和计算机相关,计算机处理输入的时候肯定是一个字节，一个字节的顺序处理，而且从效率上考虑也是先处理低字节，后处理高字节。但我们人类还是习惯从高往低读，比如你的工资是几千几百几十万几千几百几十几。</p>
<p>那计算机是怎么读取数据的呢？都是按内存地址来，从低到高的来。先读到低的，然后处理低的。这就是小端。</p>
<p>那么网络的大端，是怎么回事呢？因为制定网络协议的时候，是写在纸上给人看的，所以自然需要按照人的读写方式。比如长度<br>是258，占2个字节，那么就需要写成0x0102。因为这样才符合人类的阅读方式。1 * 256 +2 = 258。所以1.2.3.4的IP地址会在wireshark里显示0x01020304.因为是人类的方式.</p>
<p>然后我们规定在网络传输中使用大端。即高位字节先传输，地位自己后传输。所以我们以内存接受数据的时候，自然是先写低地址，后写高地址，也就是把高字节写到了低地址。也就是大端，所以需要处理的时候，还需要调用ntoh翻转一下，即低位放在低地址上。</p>
<p>你明白了么？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2018/04/26/理解字节序/" data-id="cjn4dgo9y001cbklo85tvfj1h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字节序/">字节序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络字节序，主机字节序/">网络字节序，主机字节序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-a-out的幕后" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/14/a-out的幕后/" class="article-date">
  <time datetime="2018-02-14T03:48:07.000Z" itemprop="datePublished">2018-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/14/a-out的幕后/">a.out的幕后</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="a-out结构"><a href="#a-out结构" class="headerlink" title="a.out结构"></a>a.out结构</h2><p>我们在使用gcc编译一个程序的时候，如果不指定任何选项，默认的产出都会是a.out的一个文件。那么a.out到底是什么什么结构呢？</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2018/02/14/a-out的幕后/" data-id="cjn4dgo9f000dbklogrgmf97k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RSA算法证明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/31/RSA算法证明/" class="article-date">
  <time datetime="2018-01-31T03:13:06.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/RSA算法证明/">RSA算法证明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">随机选取两个质数p1、p2，n=p1xp2，再随机选取一个整数e，e与φ(n)互质, e通常为65537, 再次计算一个d, 它是e对于φ(n)的模反元素,也就是e x d ≡ 1 (mod φ(n))</span><br><span class="line">加密过程：(m^e) mod n=c，其中m为原信息（注意m &lt; n），c为加密信息，n、e为公开密钥。</span><br><span class="line">解密过程：(c^d) mod n=m，其中d为解密密钥。</span><br></pre></td></tr></table></figure>
<p>上面就是加密和解密进行的操作了，我们后面可以证明一下，在证明之前，我们先介绍几个数学概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 a x b-1 被n整除，或者说ab被n除的余数是1，即a x b ≡ 1 (mod n)</span><br><span class="line">φ(n):小于n且与n互质的正整数的个数，比如φ(10) = 4,因为小于10且与10互质的的数为1，3，7，9</span><br><span class="line">欧拉定理：m和n互质，则m^φ(n) ≡ 1 (mod n)</span><br><span class="line">欧拉函数：如果n为质数，φ(n)=n-1</span><br><span class="line">欧拉函数是积性函数：若m,n互质， φ(mxn)=(m-1)(n-1)</span><br><span class="line">同余性质：</span><br><span class="line">1).反身性：a≡a (mod m)；</span><br><span class="line">2).对称性：若a≡b(mod m)，则b≡a (mod m)；</span><br><span class="line">3).传递性：若a≡b(mod m)，b≡c(mod m)，则a≡c(mod m)；</span><br><span class="line">4).同余式相加：若a≡b(mod m)，c≡d(mod m)，则a+c≡b+d(mod m)；</span><br><span class="line">5).同余式相乘：若a≡b(mod m)，c≡d(mod m)，则axc≡bxd(mod m)。(特殊情况c=d下也成立)</span><br><span class="line">6).幂运算：如果a≡b(mod m)，那么a^k≡b^k(mod m)；</span><br></pre></td></tr></table></figure></p>
<p>下面开始证明,也就是证明：通过解密过程，可以从加密后的数据c得到加密前的数据m<br>解密过程的运算是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c^d ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>因为加密过程为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(m^e) ≡ c (mod n)</span><br><span class="line">即</span><br><span class="line">c = m^e - k x n</span><br></pre></td></tr></table></figure><br>所以我们可以试图证明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(m^e - k x )^d ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>继续展开左边，相同与求证如下，因为看k x n的任意次方都是可以被n整除的，可以忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m^(e x d) ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>因为e和d是对于φ(n)的模反元素，即,exd = h x φ(n) + 1，就变成证明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m^(h x φ(n)+1) ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>考虑m和n互质与不互质两种情况<br>case 1：m和n互质，直接根据欧拉定理m^φ(n) ≡ 1 (mod n)，根据同余的乘法性质<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m^(h x φ(n)) x m = m (mod n)</span><br><span class="line">即</span><br><span class="line">m^(h x φ(n)+1) ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>证明完毕</p>
<p>case 2：m和n不互质，因为m &lt; n （这是算法前提），n = p x q,所以m必然为p或者q的k倍，假设m=kxp,<br>其实这时k一定和q互质，因为k x p &lt; q x p,q又是质数，然后kxp也必然和q互质。还是根据欧拉定理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(k x p)^φ(q) ≡ 1 (mod q)</span><br><span class="line">根据欧拉函数</span><br><span class="line">(k x p)^(q-1) ≡ 1 (mod q)</span><br></pre></td></tr></table></figure>
<p>继续根据同余的幂运算和乘法运算性质<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(k x p)^((q-1) x h x (p-1)) x (k x p) ≡ k x p (mod q)</span><br></pre></td></tr></table></figure><br>根据欧拉函数是积性函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(k x p)^（φ(p x q) x h) x (k x p) ≡ k x p (mod q)</span><br><span class="line">继续</span><br><span class="line">(k x p)^(φ(n) x h + 1) ≡ k x p (mod q)</span><br></pre></td></tr></table></figure><br>考虑到e和d是对于φ(n)的模反元素,即e x d = h x φ(n) + 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(k x p)^(e x d) ≡ k x p (mod q)</span><br><span class="line">换种写法</span><br><span class="line">(k x p)^(e x d) = t x q + k x p</span><br></pre></td></tr></table></figure><br>因为p是一个大质数，t x q必然整除p，q不能整除p，所以t必然整除p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(k x p)^(e x d) = t1 x p x q + k x p</span><br></pre></td></tr></table></figure><br>因为m = k x p,n = p x q，所以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m^(e x d) = t1 x n + m</span><br><span class="line">m^(e x d) ≡ m (mod n)</span><br></pre></td></tr></table></figure><br>证明完毕。</p>
<p>折腾完毕之后发现跑题了，我们只向看看指数和模数的使用而已，一句话，它们就是公钥。也就是说证书里包含了公钥。前面看到，证书里还有一些签名的东西。签名是啥呢？<br>签名就是CA对其颁发证书的一个认同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2018/01/31/RSA算法证明/" data-id="cjn4dgo900005bklosi35w1hr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SSL基础知识总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/05/SSL基础知识总结/" class="article-date">
  <time datetime="2018-01-05T01:31:27.000Z" itemprop="datePublished">2018-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/05/SSL基础知识总结/">SSL基础知识总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="SSL的相关概念"><a href="#SSL的相关概念" class="headerlink" title="SSL的相关概念"></a>SSL的相关概念</h1><p>SSL(Secure Sockets Layer)是Netscape网景公司最早研发，SSL从最早的1.0发展到2.0，3.0。后来考虑标准化的时候需要摆脱公司的影响，重新命名为TLS,Transport Layer Security。演进的版本依次为<br>1.0，1.1，1.2, 1.3应该还没有发布。</p>
<h2 id="为什么会有SSL呢"><a href="#为什么会有SSL呢" class="headerlink" title="为什么会有SSL呢"></a>为什么会有SSL呢</h2><p><img src="not_safe.png" alt=""></p>
<h2 id="SSL的基础体系PKI"><a href="#SSL的基础体系PKI" class="headerlink" title="SSL的基础体系PKI"></a>SSL的基础体系PKI</h2><p>PKI的全称为Public Key Infrastructure。百科上说：PKI是一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。那么PKI规范，包含哪些东西呢？<br>在说包含哪些东西之前，我们先思考一下，从电子商务的角度触发，会面临哪些问题？</p>
<ul>
<li>保密性 比如在传输中不给窃听盗取</li>
<li>完整性 在传输过程中，不能被篡改</li>
<li>身份认证和授权 对面是人是鬼？要能确认对方身份</li>
<li>防止抵赖 交易完成后，不承认怎么办？</li>
</ul>
<p>所以PKI体系需要解决上面的问题。</p>
<ul>
<li>完美的加密算法确保保密性和完整性，这部分就是SSL/TLS的算法部分需要提供的功能</li>
<li>CA认证中心 整个体系的核心。是对身份确认的权威机构</li>
<li>证书服务器。公开证书信息，以便用户查询证书信息或者黑名单信息等</li>
<li>Client和Server系统</li>
<li>等等</li>
</ul>
<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><p>我们知道，在传输过程中，为了保密，发送方需要把数据进行加密，接收方进行解密。其他人拿到中间数据后，因为没有密钥，所以干着急,没有办法解密。</p>
<p>加密算法通常是说对称加密算法，目前在SSL中使用最广泛的是AES(Advanced Encryption Standard)<br>以前比较常用的是DES、3DES（TripleDES），但现在已经过时。这些算法都是块加密算法，也就是对特定bit的块，一块一块的加密。目前AES都是对128字节大小的块做加密。但我们在算法里可以看到AES128和AES256，这些说的不是加密块的大小，而是密钥的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br><span class="line">ECDHE-RSA-AES256-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA384</span><br><span class="line">ECDHE-RSA-AES256-SHA    SSLv3 Kx=ECDH     Au=RSA  Enc=AES(256)  Mac=SHA1</span><br><span class="line">ECDHE-RSA-AES128-GCM-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(128) Mac=AEAD</span><br><span class="line">ECDHE-RSA-AES128-SHA256 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AES(128)  Mac=SHA256</span><br><span class="line">ECDHE-RSA-AES128-SHA    SSLv3 Kx=ECDH     Au=RSA  Enc=AES(128)  Mac=SHA1</span><br></pre></td></tr></table></figure>
<h2 id="密钥交换算法"><a href="#密钥交换算法" class="headerlink" title="密钥交换算法"></a>密钥交换算法</h2><p>上面提到的加密算法都是对称加密算法，也就是双方都需要知道加密的密钥，根据其来进行加密解密，所以密钥是安全体系的重中之重，但这密钥怎么传输呢？传输密钥的算法就是密钥交换算法。</p>
<p>目前有两类主流的密钥交换算法</p>
<ul>
<li>RSA</li>
<li>DH/ECDH</li>
</ul>
<p>RSA算法一个比较古老但还流行的算法，三位数学家Rivest、Shamir 和Adleman搞出来的。我们可以简单的说一下RSA加密原理，一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算2个大数的乘积很容易,但把大数做质数分解确很难</span><br></pre></td></tr></table></figure><br>想了解RSA的算法原理以及证明，可以参考：<a href="http://abonege.github.io/2018/01/31/RSA算法证明/">http://abonege.github.io/2018/01/31/RSA算法证明/</a></p>
<p>目前RSA是加密密钥长度已经达到2048位，在量子计算机出关之前，想破解基本没戏了。</p>
<p>DH/ECDH算法，是另外一种密钥交换算法，具体的数学原理很复杂，我们可以举个例子，简单的比喻一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Alice和Bob说，我们有个共同的参数15(公开信息).</span><br><span class="line">2.Alice产生一个随机数3（私钥），然后发给Bob  3+15</span><br><span class="line">3.Bob产生一个随机数9（私钥），然后发给Alice 9+15</span><br><span class="line">4.Bob收到18，计算自己的密钥 18 + 9 = 27</span><br><span class="line">5.Alice收到24，计算自己的密钥 24+3 = 27</span><br></pre></td></tr></table></figure></p>
<p>这样Alice和Bob协商出来了一个加密密钥</p>
<p>上面的2，3使用的算法只是简单的+，但DH算法本身是使用离散对数的原理。可以参考这个图：<br><img src="dh.png" alt=""></p>
<p>后来，人们又对DH算法做了改进，即ECDH(Elliptic Curve Diffie–Hellman)，主要是为了缓解上图中p和g的生成代价,在算法上也增加了破解难度。</p>
<p>但现在目前使用的最广泛，也基本是唯一推荐的是ECDHE算法，什么是ECDHE呢？<br>我们得先看看DH算法的分类：</p>
<ul>
<li>Anonymous Diffie-Hellman</li>
<li>Fixed Diffie-Hellman</li>
<li>Ephemeral Diffie-Hellman</li>
</ul>
<p>第一个是匿名DH算法,不认证公钥的合法性的，所以很容易收到中间人的攻击(Man-in-the-Middle attacks)。<br><img src="mim.gif" alt=""><br>第二个是固定的公钥参数. 这时类似RSA，把公钥的参数，即前面提到的p,g,A,都写入到证书，然后由CA签名，从此千秋不变。当然这时候私钥也是不变的。<br>第三个是临时的公钥参数，即每次A都是临时算出来的，也是目前主要使用的，即ECDHE，为什么呢？<br>因为下面这个小伙：<br><img src="sinuodeng.jpg" alt=""></p>
<p>ECDHE算法想要避免的问题就是：<strong>向前安全性</strong></p>
<p>当前RSA算法的加密密钥计算过程如下：<br><img src="premaster.png" alt=""><br>所以，拿到原始报文后，只要有朝一日，拿到私钥，就可以算出加密密钥，从而破解。</p>
<p>ECDHE算法就是为了避免这个事情，密钥的协商，都是临时的，阅后即焚，无法复现。但这时候的问题是，临时生成的公钥，如何避免中间人攻击，即<br>如何证明自己是可信的呢？这时候就轮到当前的主角ECDHE-RSA出场了。</p>
<p><strong>DH算法的公钥需要使用RSA的私钥做签名。对方使用RSA的公钥来验证DH公钥的合法性。</strong></p>
<h2 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h2><p>前面提到的都是加密算法，很重要，如果中间者虽然不能窃听，但篡改包还是可以的，所以需要接受者知道收到的包是否经过篡改。这就是MAC(Message Authentication Code)算法。目前支持两种MD5(Message Digest 5)和SHA(Secure Hash Algorithm)。收到包后，先解密，然后看MAC的一致性，如果不一致，则直接丢弃该报文。</p>
<h2 id="证书与签名"><a href="#证书与签名" class="headerlink" title="证书与签名"></a>证书与签名</h2><p>证书是什么呢？证书是权威机构颁发的，供个人或机构来证明自己合法身份的证明。目前有这么几类证书：</p>
<ul>
<li><p>Class 4 SSL证书：即EV SSL证书，顶级SSL证书，又称扩展验证型SSL证书。安全级别最高，验证审核最严格，网站部署EVSSL证书后，浏览器地址栏将变成绿色并显示企业名称。EV SSL证书一般应用于金融、银行、电商等安全需求较高的网站。比如<br><a href="https://ebsnew.boc.cn/boc15/login.html" target="_blank" rel="noopener">https://ebsnew.boc.cn/boc15/login.html</a></p>
</li>
<li><p>Class 3 SSL证书：即OV SSL证书，专业级SSL证书，又称机构验证型SSL证书。当前广泛应用的SSL证书，需要验证企业身份信息后颁发。OV SSL证书是当前最常见的证书类型，适用于行政、企业、科研、邮箱、论坛等各类大中型网站。</p>
</li>
<li><p>Class 2 SSL证书：即IV SSL证书，个人级SSL证书，沃通特有的SSL证书，又称个人验证型SSL证书。验证个人详细信息后颁发，主要应用于私人博客、自媒体等个人网站。</p>
</li>
<li><p>Class 1 SSL证书：即DV SSL证书，基础级SSL证书，又称域名验证型SSL证书。DV SSL证书是签发只验证域名所有权，快速颁发的SSL证书，安全级别较低。</p>
</li>
</ul>
<p>证书长什么样子呢？列举百度的证书</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">   Data:</span><br><span class="line">       Version: 3 (0x2)</span><br><span class="line">       Serial Number: 9 (0x9)</span><br><span class="line">   Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">       Issuer: C=BE, O=GlobalSign nv-sa, CN=GlobalSign Organization Validation CA - SHA256 - G2</span><br><span class="line">       Validity</span><br><span class="line">           Not Before: Feb 11 06:04:56 2015 GMT</span><br><span class="line">           Not After : Feb  8 06:04:56 2025 GMT</span><br><span class="line">       Subject: C=CN, ST=beijing, L=beijing, O=service operation department OU=Beijing Baidu Netcom Science Technology Co., Ltd, CN=baidu.com</span><br><span class="line">       Subject Public Key Info:</span><br><span class="line">           Public Key Algorithm: rsaEncryption</span><br><span class="line">               Public-Key: (2048 bit)</span><br><span class="line">               Modulus:</span><br><span class="line">                   00:a4:b0:dd:eb:c1:cf:5d:47:61:a6:ea:ef:8b:aa:</span><br><span class="line">                   4b:f0:b4:2c:d8:96:c7:7c:ac:fa:c7:35:88:53:d0:</span><br><span class="line">                   ...</span><br><span class="line">                   8a:76:dc:8f:8c:44:c8:0b:3c:36:88:5f:01:f0:44:</span><br><span class="line">                   4e:81:e6:7a:2b:ff:ba:da:33:a5:27:11:c6:f0:08:</span><br><span class="line">                   6e:f3</span><br><span class="line">               Exponent: 65537 (0x10001)</span><br><span class="line">       X509v3 extensions:</span><br><span class="line">           X509v3 Basic Constraints: </span><br><span class="line">               CA:FALSE</span><br><span class="line">           Netscape Comment: </span><br><span class="line">               OpenSSL Generated Certificate</span><br><span class="line">           X509v3 Subject Key Identifier: </span><br><span class="line">               07:C6:87:B7:C1:1E:28:E8:96:3F:EB:40:1E:82:41:45:CA:81:B6:3D</span><br><span class="line">           X509v3 Authority Key Identifier: </span><br><span class="line">               keyid:A4:C2:14:6A:39:D1:95:1E:BD:DF:3B:92:4A:5C:12:42:1B:BC:53:B8</span><br><span class="line"></span><br><span class="line">   Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        0c:c6:81:70:cd:0a:2d:94:4f:cb:a4:1d:ef:9e:8e:e4:73:ae:</span><br><span class="line">        50:62:a8:9c:64:ef:56:0f:41:fe:6b:b4:d3:07:37:39:2c:ed:</span><br><span class="line">        ...</span><br><span class="line">        6f:62:61:b8:03:d7:97:31:ab:05:44:20:07:65:8b:ad:e2:cc:</span><br><span class="line">        ad:65:73:f6:82:0f:9e:65:d0:ae:b7:1e:fd:9f:c1:d7:41:6c:</span><br><span class="line">        0f:06:95:ee</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIEMDCCAxigAwIBAgIBCTANBgkqhkiG9w0BAQsFADCBtTELMAkGA1UEBhMCQ04x</span><br><span class="line">EjAQBgNVBAgMCUd1YW5nRG9uZzERMA8GA1UEBwwIU2hlblpoZW4xJjAkBgNVBAoM</span><br><span class="line">...</span><br><span class="line">ujwwRar6pPzusO95WuS93HsNmL2ZFZ63DS4LcW9iYbgD15cxqwVEIAdli63izK1l</span><br><span class="line">c/aCD55l0K63Hv2fwddBbA8Gle4=</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大部分字段，我们通过名字，能猜出来是什么意思。关于Modulus和Exponent，不用细追究，它们是生成公钥的2个输入，公钥并不像私钥那样直接提供。而是提供了2个数，一个指数，一个是模数。这2个数可以直接生成公钥。</p>
<p>后面还有一个签名，算法为sha256WithRSAEncryption，意思是对证书先用sha256创建指纹摘要，然后使用CA的RSA私钥加密。浏览器如何验签呢？</p>
<ul>
<li>证书使用sha256算法加密后和下来的指纹是否一致</li>
<li>使用CA的公钥解密签名，看是否和指纹一样</li>
<li>还有证书过期，吊销等验证</li>
</ul>
<p>怎么认证证书的合法性呢？<br>我们的操作系统内置了很多root CA，这些CA都是有颁发签署新证书能力的。再其颁发的所有证书上，都有CA对这个证书的签名（用CA私钥）。浏览器拿到证书后，可以下载到CA的公钥，然后用公钥验证签名。从而知道证书的合法性。</p>
<h2 id="继续签名"><a href="#继续签名" class="headerlink" title="继续签名"></a>继续签名</h2><p>CA帮助我们的证书做了签名，证明了这个证书的合法性。但是我们client/server实际交互的时候，还需要一个签名，这个签名是保证，server确实拥有这个证书。</p>
<p>对于RSA来讲，这个问题是简单的。因为证书里有被CA签名过的server的公钥，client既然能使用这个公钥和server完成密钥协商，那么server一定是合法拥有这个证书的。</p>
<p>我们主要讨论后来广泛使用的ECDHE，考虑向前安全性，ECDH已经基本废了。ECDHE都是临时生成对称密钥的方式，证书里的公钥对应的私钥（保存在服务器中）没有用于协商密钥。<br>只有让其参与到ssl过程中来，才能证明其合法的拥有证书。所以ECDHE是需要签名的（这里的签名是数据传输过程中的签名，不是证书签名）。<br>通常有两种RSA和ECDSA。</p>
<p>先说RSA，为了证明server对这个证书的合法拥有，在server-key-exchange消息的时候，回把这个消息签名（使用证书私钥+RSA算法）</p>
<p><img src="rsa_sign.png" alt=""></p>
<p>再说ECDSA</p>
<p>对于ECDSA来讲，普通的证书是无法使用的，我们需要使用ECC证书，也就是证书上需要有ECC算法的公钥，我们才能使用此公钥对应的ECC私钥做签名。</p>
<h1 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h1><p>前面介绍了很多SSL的概念，知道这些概念后，了解SSL协议就方便很多了。</p>
<p>SSL协议可以认为是L5层协议，即会话层。看下图：</p>
<p><img src="ssl_record.png" alt=""></p>
<h2 id="SSL的交互过程"><a href="#SSL的交互过程" class="headerlink" title="SSL的交互过程"></a>SSL的交互过程</h2><p>我们先看一下SSL有哪些类型的消息</p>
<ul>
<li>Alert</li>
<li>ApplicationData</li>
<li>Certificate</li>
<li>CertificateRequest</li>
<li>CertificateVerify</li>
<li>ChangeCipherSpec</li>
<li>ClientHello</li>
<li>ClientKeyExchange</li>
<li>Finished</li>
<li>HelloRequest</li>
<li>ServerHello</li>
<li>ServerHelloDone</li>
<li>ServerKeyExchange</li>
</ul>
<p>基于RSA的握手<br><img src="ssl-handshake-rsa.png" alt=""></p>
<p>再看基于ECDHE的握手</p>
<p><img src="ssl-handshake-dh.png" alt=""></p>
<h1 id="关于keyless方案"><a href="#关于keyless方案" class="headerlink" title="关于keyless方案"></a>关于keyless方案</h1><p>keyless方案的出现，是基于如下的前提。</p>
<ul>
<li>在云环境中，很多客户不愿意把私钥交出来</li>
<li>异地做RSA的私钥加解密操作能带来很多扩展，尤其是在设备进云的时候</li>
</ul>
<p>使用私钥的操作为RSA握手时premaster私钥解密和DH握手时使用RSA私钥的签名。</p>
<h2 id="在openssl环境中如何设计keyless方案"><a href="#在openssl环境中如何设计keyless方案" class="headerlink" title="在openssl环境中如何设计keyless方案"></a>在openssl环境中如何设计keyless方案</h2><p>现在很多应用都是基于openssl开发的，比如nginx，haproxy等。平滑的支持keyless方案是很基本的一个需求。<br>幸好，openssl-1.1的ASYNC提供了一个简单的异步的机制。让我们可以在engine层面支持keyless，而且让上层应用基本不感知。但这个异步和aio，epoll那些还是不一样的。他就是提供了一种类似携程的东西，来完成一些SSL的异步操作。从release note上看，也一直提是为了”asynchronous capable engine”。</p>
<p>但整个方案还是需要依赖epoll等异步io机制。比如触发IN事件的时候去做SSL_read或者SSL_do_handshake这样的操作，但这些操作会返回SSL_ERROR_WANT_ASYNC,告诉app，等机会再来一次。</p>
<p>什么是engine呢？<br>engine是一个一个的so，每个so实现了openssl规定的一组函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int ENGINE_set_RSA(ENGINE *e, const RSA_METHOD *rsa_meth);</span><br><span class="line">int ENGINE_set_DSA(ENGINE *e, const DSA_METHOD *dsa_meth);</span><br><span class="line">int ENGINE_set_EC(ENGINE *e, const EC_KEY_METHOD *ecdsa_meth);</span><br><span class="line">int ENGINE_set_DH(ENGINE *e, const DH_METHOD *dh_meth);</span><br><span class="line">int ENGINE_set_RAND(ENGINE *e, const RAND_METHOD *rand_meth);</span><br><span class="line">....</span><br><span class="line">int ENGINE_set_ciphers(ENGINE *e, ENGINE_CIPHERS_PTR f);</span><br><span class="line">int ENGINE_set_digests(ENGINE *e, ENGINE_DIGESTS_PTR f);</span><br></pre></td></tr></table></figure></p>
<p>在engine中，可以自由实现你想独特实现的算法，比如rsa,只需定义好如下的函数，注册给engine即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if ((dasync_rsa_method = RSA_meth_new(&quot;Test Async RSA method&quot;, 0)) == NULL</span><br><span class="line">    || RSA_meth_set_pub_enc(dasync_rsa_method, dasync_pub_enc) == 0</span><br><span class="line">    || RSA_meth_set_pub_dec(dasync_rsa_method, dasync_pub_dec) == 0</span><br><span class="line">    || RSA_meth_set_priv_enc(dasync_rsa_method, dasync_rsa_priv_enc) == 0</span><br><span class="line">    || RSA_meth_set_priv_dec(dasync_rsa_method, dasync_rsa_priv_dec) == 0</span><br><span class="line">    || RSA_meth_set_mod_exp(dasync_rsa_method, dasync_rsa_mod_exp) == 0</span><br><span class="line">    || RSA_meth_set_bn_mod_exp(dasync_rsa_method, BN_mod_exp_mont) == 0</span><br><span class="line">    || RSA_meth_set_init(dasync_rsa_method, dasync_rsa_init) == 0</span><br><span class="line">    || RSA_meth_set_finish(dasync_rsa_method, dasync_rsa_finish) == 0) &#123;</span><br><span class="line">    DASYNCerr(DASYNC_F_BIND_DASYNC, DASYNC_R_INIT_FAILED);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不愿意或没必要实现的，可以利用原来的默认算法。</p>
<p>那么openssl里的ASYNC机制的原理是什么呢？</p>
<p>有一个基本的概念叫job。可以认为是我们的一次加密/解密操作。举例说，当client发送一个pre-master secret过来的时候，<br>server需要拿自己的私钥解密，这个解密需要把私钥和pre-master secret一起扔到ssl offload server。这时，主程序不能等着啊，你先慢慢解，我一会来接你啊<br>这里面就有2个问题了：</p>
<ul>
<li>什么时候来接你？</li>
<li>接你的时候，你还是那个你么？</li>
</ul>
<p>针对第一个问题，是需要程序作者需要维护的，比如我们需要一个epoll轮询发现解密后的数据回来了，则知道要接了。对第二个问题是更棘手些的，『你还是那个你么』<br>说的是，当前的上下文，还是那个上下文么？<br>比如我的异步解密函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int my_rsa_decrypt(arg1, arg2, arg3)</span><br><span class="line">&#123;</span><br><span class="line">    int data1_important;</span><br><span class="line">    int data2_important;</span><br><span class="line">    int async_result;</span><br><span class="line">    int result;</span><br><span class="line"></span><br><span class="line">    data1_important = xxxx();</span><br><span class="line">    data2_important = yyyy();</span><br><span class="line">    async_result = do_aync_job();</span><br><span class="line">    result = compute(data1_important, dat2_important, async_result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设我们异步的函数是do_async_job，我们在异步操作之前已经计算出来2个数,data1_important和data2_important。那我们理想的接上的方式，就应该是<br>直接执行do_async_job的下一行，且拿到了async_result这个值。没错，ASYNC就这么干的。因为他把当前的栈保存下来了。</p>
<p>举SSL_do_handshake为例，我们简述一下流程：</p>
<ul>
<li>在第一次调用SSL_do_handshake的时候，需要异步，会调用ASYNC_start_job开启一个job，并切换到job去执行（注意这里保存了『接你』栈）</li>
<li>job的func因为不能马山就绪，所以调用ASYNC_pause_job返回一个SSL_ERROR_WANT_ASYNC说等等</li>
<li>多了一会，条件好了（pre-master secret解密数据回来了），主程序二次调用SSL_do_handshake</li>
<li>在SSL_do_handshake里，会找到当前的job，然后调用ASYNC_start_job，恢复『接你』栈继续执行，从而透明的得到了一个SSL_do_handshake的结果，像什么都没发生一下样</li>
</ul>
<p>看起来挺简单的，但实际上，我们面临的问题是，谁来驱动和远端通讯的socket（加入使用tcp的话）。<br>这时候，大部分需要app感知了。举nginx为例，修改后的nginx如下：<br><img src="keyless.png" alt=""></p>
<p>nginx的epoll需要额外托和keyless server通讯的socket，幸好pipe socket不需要。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2018/01/05/SSL基础知识总结/" data-id="cjn4dgo9a0009bklo4pjiaxo7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSL/">SSL</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx实现动态resolve的思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/15/nginx实现动态resolve的思路/" class="article-date">
  <time datetime="2017-12-15T05:38:33.000Z" itemprop="datePublished">2017-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/15/nginx实现动态resolve的思路/">nginx实现动态resolve的思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><p>在nginx用作负载均衡的时候，通常配置的源站都是一个或若干个IP+端口号，但在有些需求的情况下，我们需要回源到一个域名instead of一组ip，比如有如下的需求：</p>
<ul>
<li>一个域名对应的IP列表是变化的</li>
<li>nginx部署在不同的运营商后面，解析出来的IP可能是不一样的 </li>
</ul>
<p>一个简单的upstream可能如下</p>
<pre>
    upstream server_group {
        server mysite.com;
    }
</pre>

<p>我们想支持前面提到的需求，怎么办呢？在nginx的商业版中，配置是这样的：</p>
<pre>
    upstream server_group{
        server mysite.com resolve;
    }
</pre>

<p>这样就可以动态的解析mysite.com了。<br>我没有商业版的代码，表面上能满足我们动态解析的需求，但在有些情况下，上面的配置就显得捉襟见肘了。</p>
<p>我们可以先理一下，当upstream的server列表发生变化，哪些模块会受影响呢？这是和我们使用了哪些模块有关系的，在我的场景下，有如下模块收到了影响</p>
<ul>
<li>负载均衡模块</li>
<li>健康检查模块</li>
</ul>
<p>负载均衡模块需要感知变化，是因为需要在这些server负载均衡，多了少了server那得知道<br>健康检查模块也一样的，upstream的server列表指定了需要对哪些server做检查</p>
<p>因为通常来讲，这两个模块是需要感知upstream成员变化的。那么我们到底该如何改动源站域名的动态解析呢？</p>
<h2 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h2><p>我们可以先理一下，nginx现状是什么样呢？nginx本身是支持配置域名回源的，正如前面的配置。但这个配置是一次性判定的，加载配置的时候就定下来了，后期无法改变。<br>如果你的源站一直没有变化，其实这样的配置也是足够的。</p>
<p>但我们关注的是源站可以变化的这种case，要么随着时间变化，要么随着部署环境变化（部署在移动/联通/电信的IDC里）。</p>
<h3 id="2-1-upstream模块的实现"><a href="#2-1-upstream模块的实现" class="headerlink" title="2.1.upstream模块的实现"></a>2.1.upstream模块的实现</h3><p>在做一切之前，我们需要了解upstream模块是怎么实现的，以及upstream是如何和proxy_pass协作的，一个简单的协作配置可以为如下</p>
<pre>
    upstream server_group {
        server mysite.com;
    }

    server {
        listen       80;
        server_name  abonege.com;

        location / {

            proxy_pass http://server_group/;
        }
</pre>


<p>然后proxy模块会去找名字为server_group的upstream去回源，然后从server_group里指定的server列表里选择一个回源。<br>但我们需要注意到，把proxy_pass后面的东西换成合法的域名也可以work的。</p>
<pre>
    upstream server_group {
        server mysite.com;
    }

    server {
        listen       80;
        server_name  abonege.com;

        location / {

            proxy_pass http://www.baidu.com/;
        }
</pre>

<p>那么问题来了，nginx是如何知道这是一个合法的域名还是应该从upstream里找呢？<br>看了一下代码思路是这样的：<br>首先，解析到proxy_pass的时候，不管是域名还是upstream的名字，直接当成upstream，放到upstream模块的upstream数组里,</p>
<pre>
    u.url.len = url->len - add;
    u.url.data = url->data + add;
    u.default_port = port;
    u.uri_part = 1;
    u.no_resolve = 1;  // 不用resolve
    plcf->upstream.upstream = ngx_http_upstream_add(cf, &u, 0);
</pre>

<p>当然，parse一个upstream block的时候，也会调用相同的函数，来添加一个upstream</p>
<pre>
    u.host = value[1];
    u.no_resolve = 1;  //不用resolve
    u.no_port = 1;

    uscf = ngx_http_upstream_add(cf, &u, NGX_HTTP_UPSTREAM_CREATE
                                         |NGX_HTTP_UPSTREAM_WEIGHT
                                         |NGX_HTTP_UPSTREAM_MAX_FAILS
                                         |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT
                                         |NGX_HTTP_UPSTREAM_DOWN
                                         |NGX_HTTP_UPSTREAM_BACKUP);

</pre>

<p>在ngx_http_upstream_add里有一些合并的逻辑，因为有可能先解析upstream{}这样的block，也可能先解析到proxy_pass里的upstream名字（这种情况只建了一个upstream的空壳），总之能merge起来。<br>那么回到之前的话题，我们如何区分proxy_pass里指定的是域名还是upstream的名字呢？<br>其实这发生在upstream初始化的时候</p>
<pre>
    (gdb) bt
    #0  ngx_inet_resolve_host (pool=0x6c0130, u=u@entry=0x7fffffffd9d0) at src/core/ngx_inet.c:1097
    #1  0x000000000044aacf in ngx_http_upstream_init_round_robin (cf=0x7fffffffe0a0, us=0x6dcbc0)
        at src/http/ngx_http_upstream_round_robin.c:189
    #2  0x0000000000444494 in ngx_http_upstream_init_main_conf (cf=0x7fffffffe0a0, conf=0x6c2bf0) at src/http/ngx_http_upstream.c:6103
    #3  0x000000000042e99f in ngx_http_block (cf=0x7fffffffe0a0, cmd=<optimized out="">, conf=<optimized out="">)    at src/http/ngx_http.c:262
    #4  0x000000000041c914 in ngx_conf_handler (last=1, cf=0x7fffffffe0a0) at src/core/ngx_conf_file.c:427
    #5  ngx_conf_parse (cf=cf@entry=0x7fffffffe0a0,    filename=filename@entry=0x6c0348) at src/core/ngx_conf_file.c:283
    #6  0x000000000041a38a in ngx_init_cycle (old_cycle=old_cycle@entry=0x7fffffffe150) at src/core/ngx_cycle.c:274
    #7  0x000000000040bcce in main (argc=<optimized out="">, argv=<optimized out="">) at src/core/nginx.c:276
</optimized></optimized></optimized></optimized></pre>

<p>ngx_inet_resolve_host就是我们要找的地方了。如果ngx_http_upstream_srv_conf_t里挂了server列表（例如upstream server_group），则走一个分支，如果是没有挂server列表的<br>则有可能是域名回源，然后对其进行域名解析，如果这种情况还是解析不了的，说明是瞎编的一个名字，既不是域名也不是upstream名字，则在启动的时候会报错，说host not found之类的。<br>总结一下：先看这个名字是不是upstream的名字，如果不是则尝试当成一个域名解析，成功则以，不成功则报错。</p>
<p>好啦，我们继续下一个问题，前面提到的mysite.com是什么时候解析的呢？因为我们想实现动态解析，必须知道当前是怎么解析的。<br>继续看ngx_http_upstream_init_round_robin<br>悲喜交加的是，你会发现，不知道什么时候，mysite.com已经被解析好躺在server的怀抱里了</p>
<pre>
    for (i = 0; i < us->servers->nelts; i++) {
        if (server[i].backup) {
            continue;
        }

        for (j = 0; j < server[i].naddrs; j++) {
            peer[n].sockaddr = server[i].addrs[j].sockaddr;
            peer[n].socklen = server[i].addrs[j].socklen;
            peer[n].name = server[i].addrs[j].name;
            peer[n].weight = server[i].weight;
            peer[n].effective_weight = server[i].weight;
            peer[n].current_weight = 0;
            peer[n].max_fails = server[i].max_fails;
            peer[n].fail_timeout = server[i].fail_timeout;
            peer[n].down = server[i].down;
            peer[n].server = server[i].name;
</pre>

<p>那么，server[i].addrs到底是啥时候解析出来的呢？在加载配置文件的时候</p>
<pre>
    gdb) bt
    #0  ngx_inet_resolve_host (pool=pool@entry=0x6c0130, u=u@entry=0x7fffffffd550) at src/core/ngx_inet.c:1120
    #1  0x0000000000413572 in ngx_parse_inet_url (u=0x7fffffffd550, pool=0x6c0130) at src/core/ngx_inet.c:787
    #2  ngx_parse_url (pool=0x6c0130, u=u@entry=0x7fffffffd550) at src/core/ngx_inet.c:545
    #3  0x0000000000444302 in ngx_http_upstream_server (cf=0x7fffffffe0a0, cmd=<optimized out="">, conf=0x6d26b0)
        at src/http/ngx_http_upstream.c:5631
    #4  0x000000000041c914 in ngx_conf_handler (last=0, cf=0x7fffffffe0a0) at src/core/ngx_conf_file.c:427
</optimized></pre>

<p>所以，综上，我们认为在加载完毕配置文件的时候，想要的东西都好了。比如proxy和upstream的关联，upstream内部server名字的解析。但这一切都发生在解析文件的时候，<br>也就是一锤子打死的配置，不能变化，但我们要的就是变化，该当如何呢？</p>
<h2 id="2-2-我们的方案"><a href="#2-2-我们的方案" class="headerlink" title="2.2.我们的方案"></a>2.2.我们的方案</h2><p>我们注意到，在ngx_http_upstream_init_request里居然还有</p>
<pre>
    ngx_resolve_start...
    ngx_http_upstream_resolve_handler...
</pre>

<p>这个逻辑是干啥用的么,看起来很像运行太解析的，对不对？难道nginx自动支持动态DNS解析么，想多了。那个商业版才有的。是这样的，因为proxy_pass传递的参数里，是可以以变量形式配置的</p>
<pre>
    proxy_pass http://$dest_hostname/;
</pre>

<p>如果$dst_hostname是动态解析出来的,比如针对a请求$dest_hostname翻译成a.com，针对b请求翻译成b.com，辣么这个回源的域名就是动态变化的，就需要我们动态解析。</p>
<p>有没有发现，已经在一定程度上解决我们的问题了。但前提是，我们不是用upstream回源，而是直接采用域名回源（nginx变量的形式）。<br>这样就能动态的翻译源站域名到不同的IP了。解决了我们的一部分问题，但还有别的问题，需要我们搞定，比如回话保持，健康检查都是配置在upstream里的。<br>如果我们不用upstream回源，相当于这部分功能无法使用了。那么应该怎么搞呢？</p>
<p>举tengine的dyups模块为例，他的工作原理大致如下，当一个nginx worker进程收到一个创建upstream的API后，会验证upstream的配置语法，然后通过share memory传递给其他的<br>worker。然后各个worker会把这个upstream同步给自己的内存，注意，这时候会调用健康检查的添加peer的逻辑，以及对应算法模块的初始化（rr,lc,haship等算法的初始化逻辑是不一样的）</p>
<p>所以我们为了支持动态解析，动手的逻辑应该是这里。</p>
<ul>
<li>持久化dyups的原始配置信息，虽然每个worker进程知道upstream信息，但是从upstream信息反推配置是很困难的。因为每次域名解析的内容变动后，我们需要重新构造dyups的upstream配置block</li>
<li>周期的检查dyups的所有upstream配置，然后进行dns解析，这里nginx已经提供了很友好的函数。</li>
</ul>
<p><pre><br>    ngx_resolve_start…<br>    ngx_http_upstream_resolve_handler…<br></pre></p>
<ul>
<li>如果发现dyups的server域名已经发生变化，则走dyups update流程，即删除旧的upstream，创建新的upstream</li>
</ul>
<p>其实说句实话，选一个worker是不好选择的，我的建议是有一个专门的controller进程，用于做这件事。</p>
<p>以上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/12/15/nginx实现动态resolve的思路/" data-id="cjn4dgo9o000pbklo1x0jsa8e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/resolve/">resolve</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/upstream/">upstream</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx上支持手工封禁请求的的思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/nginx上支持手工封禁请求的的思路/" class="article-date">
  <time datetime="2017-11-07T08:04:35.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/07/nginx上支持手工封禁请求的的思路/">nginx上支持手工封禁请求的的思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h1><p>越来越多的厂家通过nginx扩展的方式来实现CC防护，如何实现自动防护是一个很大的课题，我们先不讨论，本文主要想讨论的是，知道封禁规则的情况下，如何实现封禁。</p>
<h1 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h1><p>封禁的规则，自然有很多条件比如</p>
<ul>
<li>clientip</li>
<li>一个client（ip标识或什么标识）的访问速度</li>
<li>URL</li>
<li>User-Agent</li>
<li>query</li>
<li>cookie</li>
<li>header</li>
<li>referrer</li>
</ul>
<p>其中上面任何几个可以混杂，比如我们知道了一个可疑的URL（攻击者频繁访问的URL），我们可以根据2和3混合起来，比如访问”/“的速度大于10qps的才封禁。也可能是user-agent为Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 ,访问/的条件。</p>
<p>总之可以随意混合起来，设置清洗条件。</p>
<p>那么我么改如何组织这些条件形成的规则，并且根据这些规则进行清洗呢？</p>
<p>粗糙一点，维护一个列表，每个元素是一个规则，每个规则里包含若干条件。<br>当一个请求到来的时候，遍历规则中的每个条件，如果都匹配，则认为规则匹配，然后执行对应的动作。否则判断下一个规则。依次类推。</p>
<p>但这样效率是不是有点低下了，有女朋友的工程师可能就满足了，但大部分显然不会。</p>
<p>进阶一点，我们把这些有限的特征类别分别组织一下，比如可能归类如下的几种：</p>
<ul>
<li>client ip以及此ip访问速率</li>
<li>URL</li>
<li>User-Agent</li>
<li>Referer</li>
<li>cookie</li>
<li>header</li>
</ul>
<p>当然酌情可以更多，我们可以把所有规则下的所有条件，分别扔到对应的分类里去。各个分类自己组织自己的查找结构，比如IP的用bit二分查找或者hash表，url是hyperscan<br>host的用字符串匹配等等。<br><img src="rules.png" alt=""></p>
<p>整体上的流程就是，依次过这些所有的分类检查，如果匹配上，则在回调里设置相应的flag，如果rule的所有flags已经标志满，则认为该规则匹配上了，则执行相应的处理。<br>所以这样，我们基本不受规则数目影响，来完成所有规则的匹配操作。需要注意的是，我们可能在一个分类里hit上多个条件，记得每个都需要标志flag，不能只关心第一个。</p>
<p>再进阶一点，如果匹配的规则，也就是rule支持了优先级会怎样？我们怎么找到最高的优先级呢？有了上面的基础，我相信不困难了。<br>也就是当一个规则的flags标志满以后，不急于执行action，而是把规则和优先级记录在ctx上，如果后面有了更高级别优先级的rule匹配上了，则替换之，<br>总之会在所有的分类匹配结束后，得到一个最合适的rule，然后再执行回调即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/11/07/nginx上支持手工封禁请求的的思路/" data-id="cjn4dgo9m000lbklo9kouqjep" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CC防护，nginx，封禁/">CC防护，nginx，封禁</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hyperscan使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/06/hyperscan使用/" class="article-date">
  <time datetime="2017-11-06T08:08:43.000Z" itemprop="datePublished">2017-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/06/hyperscan使用/">hyperscan使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><p>intel在2015年10月开源了其第一个hyperscan版本4.0。在其之前很多网络设备公司都自研或使用类似pcre之类的正则匹配工具。<br>也许是dpdk的光环太多，导致大家对hyperscan也趋之若鹜。而且从实际来看，hyperscan也确实表现不俗。<br>本文主要介绍一下hyperscan的一些概念，基础使用，以及在性能敏感的情况下的一些注意事项。</p>
<h2 id="2-环境"><a href="#2-环境" class="headerlink" title="2.环境"></a>2.环境</h2><p>工欲善其事，必先利其器。但hyperscan这个器，也需要在特定的环境下，才能表现出你要的性能来。hyperscan的表现和平台以及cpu是紧密相关的。<br>在compile正则的时候，我们可以指定平台，比如haswell，Sandy Bridg。也可以指定CPU的指令集，比如AVX 2和AVX512等。<br>hyperscan可以充分利用如下的指令集。</p>
<ul>
<li>Intel Streaming SIMD Extensions 4.2 (SSE4.2)</li>
<li>the POPCNT instruction</li>
<li>Bit Manipulation Instructions (BMI, BMI2)</li>
<li>Intel Advanced Vector Extensions 2 (Intel AVX2)</li>
</ul>
<p>我们可以通过如下的指令看看本机的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>关于软件也确实有一些要求：</p>
<ul>
<li>GCC, v4.8.1 or higher</li>
<li>Clang, v3.4 or higher (with libstdc++ or libc++)</li>
<li>Intel C++ Compiler v15 or higher</li>
</ul>
<p>编译的时候，需要一些依赖的lib</p>
<table>
<thead>
<tr>
<th>lib</th>
<th>Version</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMake</td>
<td>&gt;=2.8.11</td>
<td></td>
</tr>
<tr>
<td>Ragel</td>
<td>6.9</td>
<td></td>
</tr>
<tr>
<td>Python</td>
<td>2.7</td>
<td></td>
</tr>
<tr>
<td>Boost</td>
<td>&gt;=1.57</td>
<td></td>
</tr>
<tr>
<td>Pcap</td>
<td>&gt;=0.8</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="3-编译正则表达式"><a href="#3-编译正则表达式" class="headerlink" title="3.编译正则表达式"></a>3.编译正则表达式</h2><p>为什么需要编译正则表达式呢？这也正好是多模匹配（我理解的）的一个特点了。多模匹配是说一个待匹配字符串和目标N个正则表达式匹配，得到匹配上的正则表达式，进行响应的处理。单模匹配自然是说一次只能判断是否和一个正则表达式匹配。如果想和多个正则表达式匹配，那就只能for循环了。</p>
<p>hyperscan就是用于支持多个正则表达式匹配的，内部状态机超级复杂，但好处是，基本以O（n）甚至更少的的代价，查找出其匹配的正则表达式。</p>
<p>把一组正则表达式编译好的二机制叫做pattern database。我们可以通过如下3个API，去执行编译操作：</p>
<ul>
<li>hs_compile(): 把一个正则表达式编译成一个pattern database</li>
<li>hs_compile_multi(): 把一组正则表达式编译成一个pattern database.</li>
<li>hs_compile_ext_multi(): 基本和2一样，但多了一些参数可以设置，基本用于帮助我们限制一些查匹配件，以至于更快结束匹配过程，我们后续介绍。</li>
</ul>
<p>当编译正则表达式的时候，我们需要决定，我们后续的匹配使用什么样的方式？hyperscan允许我们使用如下的三种方式：</p>
<ul>
<li>Stream模式：流模式匹配，即待匹配数据不是连续的一块，比如tcp stream，我们的正则可能匹配的数据是跨块的。</li>
<li>Block模式：待匹配的数据很明确，就在这个块里。</li>
<li>Vector模式：在Stream和Block之间的模式，数据在指定的一系列Block里。</li>
</ul>
<p>使用哪种模式，需要我们的权衡，单纯的从性能比较，BLock模式肯定最好，因为比Stream模式比较，少了对跨块的内部状态的跟踪。但Stream能很好的解决包分多Block来的情况。</p>
<h3 id="3-1-支持什么样的正则？"><a href="#3-1-支持什么样的正则？" class="headerlink" title="3.1.支持什么样的正则？"></a>3.1.支持什么样的正则？</h3><p>hyperscan对正则的支持比PCRE要少，但对于我们大多数人来说是足够用了，我们可以简单的看一下：</p>
<ul>
<li>所有字符串字符以及字符转义的匹配</li>
<li>字符类（charactor class） . (dot), [abc], 和 [^abc]，以及\s, \d, \w, \v,及其否定形式(\S, \D, \W, \V, and \H).</li>
<li>量词形式?,*,+,{n}, {m,n}, {n,}</li>
<li>多选模式  foo|bar</li>
<li>锚 ^, $, \A, \Z 和 \z.</li>
<li>选项 i，m，s，x等</li>
</ul>
<p>差不多够用了不是？不支持的我都不知道啥意思</p>
<h3 id="3-2-关于匹配的语义Semantics"><a href="#3-2-关于匹配的语义Semantics" class="headerlink" title="3.2.关于匹配的语义Semantics"></a>3.2.关于匹配的语义Semantics</h3><p>语法是和PCRE相同的，但语义Semantics是标准正则表达式是不一样的。不一样的有这么几个地方</p>
<ul>
<li>多模匹配：hyperscan的匹配是一次匹配多个正则表达式,这和PCRE里的 表达式1|表达式2|表达式3 这样从左到右依次匹配是不一样的</li>
<li>无序：由于是多模匹配，所以多个表达式是一起匹配的，没有明显顺序，虽然基本按照谁先到匹配边界谁先结束</li>
<li>默认仅返回匹配的尾部offset：默认情况下，在返回的时候，仅仅知道匹配的end的offset，如果想知道begin offset。需要编译的时候设置flag，但会影响性能</li>
<li>全量匹配：比如从fooxyzbarbar里匹配/foo.*bar/, 默认PCRE采用贪婪匹配方式，只会匹配fooxyzbarbar，但hyperscan会匹配fooxyzbar和fooxyzbarbar两个。</li>
</ul>
<p>在stream模式下，像PCRE语义那样支持最长匹配是不太可能的。还是举上面的例子，正则是 /foo.*bar/,如果数据分下面的3个block来：<br>block 1    | block 2 | block 3<br>fooxyzbar | baz |qbar</p>
<p>Stream模式最多匹配到第一个block就结束了，因为block 2又不匹配，考虑到效率，hyperscan不会无限制的等待后面是否有个bar了。否则，如果第500个block里有个bar，该怎么搞呢？</p>
<h3 id="3-3-SOM"><a href="#3-3-SOM" class="headerlink" title="3.3.SOM"></a>3.3.SOM</h3><p>SOM是Start of Match。表示哪里开始匹配，我们之前也介绍过，默认情况下hyperscan只记录end of Match，不记录Start of Match。如果非要记录SOM，我们可以<br>在编译的时候设置 HS_FLAG_SOM_LEFTMOST这个flag。但设置之后有如下的缺点：</p>
<ul>
<li>减少hyperscan支持的正则样式。可能在编译的时候出现『Pattern too large』这样的错误</li>
<li>增加Stream模式的状态，很容易了解，多了记录内容了嘛</li>
<li>性能问题</li>
<li>和其他的一些flag不兼容。 比如HS_FLAG_SINGLEMATCH和 HS_FLAG_PREFILTER。</li>
</ul>
<p>此外，考虑性能问题，我们在使用SOM的时候，可以设置一个阈值，即start offset和end offset之间的差值，太长了还没到结尾的话，就重新来过，来减少过多的内部状态追踪</p>
<h3 id="3-4-扩展参数"><a href="#3-4-扩展参数" class="headerlink" title="3.4.扩展参数"></a>3.4.扩展参数</h3><p>我们在hs_compile_ext_multi里提到的扩展参数，</p>
<ul>
<li>flags: flags标记</li>
<li>min_offset: 用于标识最小匹配的offset</li>
<li>max_offset: 用于标识最大匹配的offset</li>
<li>min_length: 最小匹配多长</li>
<li>edit_distance: Levenshtein距离参数，用于模糊匹配.</li>
</ul>
<p>比如还是正则表达式/foo.*bar/，如果指定min_offset是10，max_offset是15的话，foobar和foo0123456789bar就不会匹配，而foo0123bar和foo0123456bar就会匹配。</p>
<p>如果edit_distance是2的话，foobar, fooba, fobr, fo_baz, foooobar和/foobar/都会匹配</p>
<h2 id="4-匹配过程"><a href="#4-匹配过程" class="headerlink" title="4.匹配过程"></a>4.匹配过程</h2><p>hyperscan对于上面的3种模式，也提供了不同的scan函数,都是以hs_scan开头。<br>一旦一个正则匹配后，会回调下面的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef (* match_event_handler)(unsigned int id, unsigned long long from, unsigned long long to, unsigned int flags, void *context)</span><br></pre></td></tr></table></figure>
<p>这个函数的返回非0的话停止匹配，否则继续匹配下去，直到找到满意的。<br>from参数就是前面提到的start of match，to就是end of match，</p>
<h3 id="4-1-Stream模式"><a href="#4-1-Stream模式" class="headerlink" title="4.1.Stream模式"></a>4.1.Stream模式</h3><p>在stream模式里会调用如下几个函数</p>
<ul>
<li>hs_open_stream()</li>
<li>hs_scan_stream()</li>
<li>hs_close_stream()<br>匹配上正则后，会回调callback，callback函数如果返回非0，则终止此次匹配过程。虽然在callback里中止了，但实际上stream的状态机还是停留在一个一个状态。<br>后续如果继续调用hs_scan_stream，会立即返回HS_SCAN_TERMINATED。 最终还是需要调用者调用一个hs_close_stream，去释放资源。<br>再次强调一下，由于Stream需要记录跨块扫描的内部状态，所以会有一定的性能损耗。</li>
</ul>
<p>hyperscan也是从前往后的匹配，当遇到 $ \b等字符时，并不会在当前stream就发生回调，只有在收到下一个stream或者stream关闭的时候才能决定回调与否</p>
<h4 id="4-1-1-Stream的管理"><a href="#4-1-1-Stream的管理" class="headerlink" title="4.1.1.Stream的管理"></a>4.1.1.Stream的管理</h4><p>除了前面提到的几个stream的操作函数，还有如下的API可是使用</p>
<ul>
<li>hs_reset_stream(): resets a stream to its initial state; this is equivalent to calling hs_close_stream() but will not free the memory used for stream state.</li>
<li>hs_copy_stream(): constructs a (newly allocated) duplicate of a stream.</li>
<li>hs_reset_and_copy_stream(): constructs a duplicate of a stream into another, resetting the destination stream first. This call avoids the allocation done by hs_copy_stream().</li>
</ul>
<p>此外stream还支持如何在stream的内容是压缩的情况下做scan操作</p>
<ul>
<li>hs_compress_stream()</li>
<li>hs_expand_stream()</li>
<li>hs_reset_and_expand_stream()</li>
</ul>
<h3 id="4-2-Block模式"><a href="#4-2-Block模式" class="headerlink" title="4.2.Block模式"></a>4.2.Block模式</h3><p>Block模式特别简单，调用hs_scan()即可。</p>
<h3 id="4-3-Vector模式"><a href="#4-3-Vector模式" class="headerlink" title="4.3.Vector模式"></a>4.3.Vector模式</h3><p>使用API hs_scan_vector()从block数组做正则匹配，从调用者来看，从block list里scan和a)把这些block看成stream的若干写入或b）把这些block list通过memcpy拼写成一个大的block，匹配的效果是一样的。但还需要根据实际情况决定使用哪种模式</p>
<h3 id="4-4-Scratch空间"><a href="#4-4-Scratch空间" class="headerlink" title="4.4.Scratch空间"></a>4.4.Scratch空间</h3><p>当做正则扫描的时候，需要一些额外的内存，来保存运行时内部数据。如果栈上申请又比较大，运行时临时申请又影响性能，所以需要我们提前申请的这些空间，我们叫<br>Scratch空间。</p>
<p>我们使用 hs_alloc_scratch()来申请Scratch空间，指定pattern database即可，不需要我们知道具体空间大小。如果我们有多个database的话，虽然我们会对<br>每个database调用hs_alloc_scratch，但实际上只生成一个一份大小最合适的Scratch空间。</p>
<ul>
<li>如果是递归scan，比如在回调的时候再做另一次scan，这时需要2个Scratch空间</li>
<li>没有递归的情况下，Scratch空间应是per-thread的</li>
<li>如果是一写多读的话，我们推荐使用hs_clone_scratch() 来替代多次 hs_alloc_scratch() </li>
</ul>
<h3 id="4-5-关于自定义内存申请-释放函数"><a href="#4-5-关于自定义内存申请-释放函数" class="headerlink" title="4.5.关于自定义内存申请/释放函数"></a>4.5.关于自定义内存申请/释放函数</h3><p>默认情况下，我们都使用malloc/free作为内部申请函数，如果我们系统自己构造了自己的内存管理函数的话，把下面一些函数赋值成自己的函数即可：</p>
<ul>
<li>hs_set_database_allocator(), which sets the allocate and free functions used for compiled pattern databases.</li>
<li>hs_set_scratch_allocator(), which sets the allocate and free functions used for scratch space.</li>
<li>hs_set_stream_allocator(), which sets the allocate and free functions used for stream state in streaming mode.</li>
<li>hs_set_misc_allocator(), which sets the allocate and free functions used for miscellaneous data, such as compile error structures and informational strings.</li>
</ul>
<h2 id="5-关于序列化"><a href="#5-关于序列化" class="headerlink" title="5.关于序列化"></a>5.关于序列化</h2><p>对于一些应用来说，确保scan操作之前，pattern database编译好了即可。但对于一些应用来说，也有其他的考量。比如：</p>
<ul>
<li>在其他主机上编译database（如果规则特别多，编译起来很慢的）</li>
<li>把编译好的database持久化起来，仅在正则该表的时候才重新编译</li>
<li>随时根据情况调整database的所在内存，比如从A地址迁移到B地址</li>
</ul>
<p>但database在内存的存储里不是顺次存放的，里边有指针引用来引用去，为了让database是可移植的，所以hyperscan提供了如下的函数：</p>
<ul>
<li>hs_serialize_database(): serializes a pattern database into a flat relocatable buffer of bytes.</li>
<li>hs_deserialize_database(): reconstructs a newly allocated pattern database from the output of hs_serialize_database().</li>
<li>hs_deserialize_database_at(): reconstructs a pattern database at a given memory location from the output of hs_serialize_database().</li>
<li>hs_serialized_database_size(): given a serialized pattern database, returns the size of the memory block required by the database when deserialized.</li>
<li>hs_serialized_database_info(): given a serialized pattern database, returns a string containing information about the database. This call is analogous to hs_database_info().</li>
</ul>
<h2 id="6-关于性能考虑"><a href="#6-关于性能考虑" class="headerlink" title="6.关于性能考虑"></a>6.关于性能考虑</h2><p>性能是我们使用hyperscan最最重要的原因，但不恰当的使用，会导致性能大打折扣。我们依次列举一下可能的影响性能的因素，大家共勉：</p>
<h3 id="6-1-不要手工优化表达式"><a href="#6-1-不要手工优化表达式" class="headerlink" title="6.1.不要手工优化表达式"></a>6.1.不要手工优化表达式</h3><p>hyperscan比我们更懂正则表达式，比如不区分大小写匹配/abc/，如下几种写法都可以：</p>
<ul>
<li>/[Aa][Bb][Cc]/</li>
<li>/(A|a)(B|b)(C|c)/</li>
<li>/(?i)abc(?-i)/</li>
<li>/abc/i</li>
</ul>
<h3 id="6-2-不必刻意优化对lib的使用"><a href="#6-2-不必刻意优化对lib的使用" class="headerlink" title="6.2.不必刻意优化对lib的使用"></a>6.2.不必刻意优化对lib的使用</h3><p>hyperscan能处理很多case，比如小包流，超大包等。除非确实遇到性能问题，否则就用最简单的方式使用hyperscan即可,即大道至简。比如我们知道block模式的匹配效果比stream的匹配效果好，但没有必要特意把一个stream上的所有数据收齐了后一起比较，除非包是一个字节一个字节收到的。<br>此外，hyperscan的性能随着正则表达式数量增加而性能逐渐下降，是平滑的，不想其他有些软件那样当到达一个阈值后陡降，这是hyperscan的一个优点<br>hyperscan的throughput也很大，对于3.0G频率的CPU来说，一个core在1us内能scan 3000-bit block 数据。但并不意味着22us能扫描完毕22*3000-bit block数据。<br>所以不要试图缓存数据来提升scan性能</p>
<h3 id="6-3-如可能尽量使用block模式"><a href="#6-3-如可能尽量使用block模式" class="headerlink" title="6.3.如可能尽量使用block模式"></a>6.3.如可能尽量使用block模式</h3><p>block的性能表现要比stream好很多</p>
<h3 id="6-4-pattern-database的拆解"><a href="#6-4-pattern-database的拆解" class="headerlink" title="6.4.pattern database的拆解"></a>6.4.pattern database的拆解</h3><p>如果我们需要统计5种不同的流量，最好建立5个pattern database，分别存放5种待待匹配特征，而不是把所有正则混在一个database里，除非这5种流量的绝大部分的待匹配的内容是一样的，比如第一种流量里有abc，第二种也有，以此类推，并且相同的程度到达90%。</p>
<h3 id="6-5-scratch空间"><a href="#6-5-scratch空间" class="headerlink" title="6.5.scratch空间"></a>6.5.scratch空间</h3><ul>
<li>提前申请好scratch空间，不要到匹配的时候申请，而是编译好database后马上申请。</li>
<li>为每个context(一个线程)申请一个，不同的database可以复用一个scratch空间</li>
</ul>
<h3 id="6-7-多使用锚"><a href="#6-7-多使用锚" class="headerlink" title="6.7.多使用锚"></a>6.7.多使用锚</h3><ul>
<li>如果明确从开始匹配则使用\A或^作为表达式的开头 比如\^abc\</li>
<li>如果明确结尾可使用$, \z 和 \Z</li>
<li>前面提到的min_offset和max_offset扩展参数，可以提前帮我们判定匹配结束</li>
</ul>
<h3 id="6-8-避免任意匹配"><a href="#6-8-避免任意匹配" class="headerlink" title="6.8.避免任意匹配"></a>6.8.避免任意匹配</h3><p>比如 /.<em>/这样的正则会导致我们进行最多次的匹配，比如abcd这样的字符，会返回5次回调(pcre因为采用贪婪匹配只会返回最后的一个)<br>另外一个就是待匹配正则的前面和后面不要有可选的部分，比如/x?abcd</em>/   前面的x?就是多余的，不影响匹配结果，后面的*也会导致我们匹配很多次<br>如果把这个正则改写成/abc/就会好很多，因为</p>
<ul>
<li>匹配/abc/的集合包含匹配/x?abcd*/，</li>
<li>匹配次数明显减少，比如样本 0123abcdddd 匹配/abc/一次，但匹配/x?abcd*/高达5次。abc  abcd abcdd abcddd abcddd</li>
</ul>
<h3 id="6-9-在stream模式下避免使用高重复的方式"><a href="#6-9-在stream模式下避免使用高重复的方式" class="headerlink" title="6.9.在stream模式下避免使用高重复的方式"></a>6.9.在stream模式下避免使用高重复的方式</h3><p> /X.{1000,1001}abcd/ 高达1000多次的重复，会给性能带来很大的影响</p>
<h3 id="6-10"><a href="#6-10" class="headerlink" title="6.10."></a>6.10.</h3><p>需要匹配的字符尽早出现，可变的部分或者正则发部分扔到后面去<br>/\wab\d<em>\w\w\w/ 比下面的好<br>/\w\w\d</em>\w\w/,<br>/\w(abc)?\d*\w\w\w/ </p>
<p>隐式的一些声明也比没有字符好，比如/[0-2][3-5].<em>\w\w/ 也有效的包含了一些信息,注意，即使展开的很详细，比如/(03|04|05|13|14|15|23|24|25).</em>\w\w/也是没啥帮助的</p>
<p>越长字符越有帮助，比如100个字符的表达式里有14字符比有4个字符性能会高出很大一截。</p>
<h3 id="6-11-使用Dot-all"><a href="#6-11-使用Dot-all" class="headerlink" title="6.11.使用Dot all"></a>6.11.使用Dot all</h3><p>Dot all模式，是使用HS_FLAG_DOTALL 这个标志控制的，关闭的话的代价会比较大。 /A.<em>B/ 会变成 /A[^\n]</em>B/.也就是跨行匹配。我们在执行匹配的时候<br>如果能1行匹配一次，最好打开这个标志</p>
<h3 id="6-12仅匹配一次"><a href="#6-12仅匹配一次" class="headerlink" title="6.12仅匹配一次"></a>6.12仅匹配一次</h3><p>前面提到过，hyperscan是多次匹配的，如果设计上确实只需要匹配一次就行了，比如有10条封禁规则，任何一条都可以封禁的话，那么该模式就需要启动。<br>可以通过(HS_FLAG_SINGLEMATCH)来开启这个模式</p>
<h3 id="6-13-SOM"><a href="#6-13-SOM" class="headerlink" title="6.13.SOM"></a>6.13.SOM</h3><p>这个前面已经提到过，如果没有必要，需要关闭这个</p>
<h3 id="6-14-模糊匹配"><a href="#6-14-模糊匹配" class="headerlink" title="6.14.模糊匹配"></a>6.14.模糊匹配</h3><p>这个也是明显降低行呢功能的，能不用尽量不用</p>
<h2 id="7-一些测试数据"><a href="#7-一些测试数据" class="headerlink" title="7.一些测试数据"></a>7.一些测试数据</h2><p>我们做一点测试的对比，先不测正则，只测试子串查找，子串是16字节的数据，待匹配串是随机的64到96长度的串<br>测试多模匹配，子串个数分别测试1，8，16，测试算法是 strstr，ac，以及hyperscan,测试100w数据的匹配时间。</p>
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:center">1个子串</th>
<th style="text-align:center">8个子串</th>
<th style="text-align:center">16个子串</th>
<th style="text-align:right">64个子串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">strstr</td>
<td style="text-align:center">7.660327</td>
<td style="text-align:center">48.659695</td>
<td style="text-align:center">95.293705</td>
<td style="text-align:right">358.87231</td>
</tr>
<tr>
<td style="text-align:left">hyperscan</td>
<td style="text-align:center">12.827749</td>
<td style="text-align:center">20.445274</td>
<td style="text-align:center">22.351201</td>
<td style="text-align:right">22.909993</td>
</tr>
<tr>
<td style="text-align:left">ac</td>
<td style="text-align:center">101.493826</td>
<td style="text-align:center">101.534645</td>
<td style="text-align:center">101:596807</td>
<td style="text-align:right">102:515976</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/11/06/hyperscan使用/" data-id="cjn4dgo9j000hbklokj8arpx2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RegEx/">RegEx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hyperscan/">hyperscan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/intel/">intel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于编译hyperscan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/23/关于编译hyperscan/" class="article-date">
  <time datetime="2017-05-23T11:26:12.000Z" itemprop="datePublished">2017-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/23/关于编译hyperscan/">关于编译hyperscan</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CMAKE"><a href="#CMAKE" class="headerlink" title="CMAKE"></a>CMAKE</h2><p>hyperscan是基于cmake生成Makefile，所以我们先需要下载cmake，我这里用的是3.9.5版本。<br>cmake我理解就是一个自动化构建编译工程文件(比如makefile，VS的 .proc文件)的东西,类似bjam。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf cmake-3.9.5.tar.gz</span><br><span class="line">cd cmake-3.9.5</span><br><span class="line">./configure</span><br><span class="line">gmake -j 20</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>至此cmake安装完毕</p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h3><p>需要boost的regex lib，我们把boost解压到/opt目录下</p>
<h3 id="ragel"><a href="#ragel" class="headerlink" title="ragel"></a>ragel</h3><p>我安装的是6.10版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/configure --prefix=/opt/</span><br><span class="line">make -j 20</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h3 id="pcap"><a href="#pcap" class="headerlink" title="pcap"></a>pcap</h3><p>我安装的是1.8.1版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/configure --prefix=/opt/</span><br><span class="line">make -j 20</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h3 id="dbus"><a href="#dbus" class="headerlink" title="dbus"></a>dbus</h3><p>我安装的是dbus-1.11.12版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/configure --prefix=/opt/</span><br><span class="line">make -j 20</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h3 id="最后准备"><a href="#最后准备" class="headerlink" title="最后准备"></a>最后准备</h3><p>修改一下CMakefileList 加入头文件和lib依赖目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/boost_1_65_1/boost &lt;hyperscan-src&gt;/include/boost</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/src)</span><br><span class="line">include_directories($&#123;PROJECT_BINARY_DIR&#125;)</span><br><span class="line">include_directories(SYSTEM include)</span><br><span class="line">include_directories(/opt/include)   &lt;----------</span><br><span class="line"></span><br><span class="line">include ($&#123;CMAKE_MODULE_PATH&#125;/boost.cmake)</span><br><span class="line"></span><br><span class="line">link_directories(&quot;/opt/lib&quot;)     &lt;---------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装hyperscan"><a href="#安装hyperscan" class="headerlink" title="安装hyperscan"></a>安装hyperscan</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;where-you-want-to-build-hyperscan&gt;</span><br><span class="line">mkdir &lt;build-dir&gt;</span><br><span class="line">cd &lt;build-dir&gt;</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; -DCMAKE_C_COMPILER=/opt/compiler/gcc-4.8.2/bin/gcc  -DCMAKE_INSTALL_PREFIX=/opt/ ../</span><br></pre></td></tr></table></figure>
<p>在编译的时候会提示ELSE分支问题，需要修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (FAT_RUNTIME)</span><br><span class="line">    if (NOT HAVE_SSSE3)</span><br><span class="line">        message(FATAL_ERROR &quot;SSSE3 support required to build fat runtime&quot;)</span><br><span class="line">    endif ()</span><br><span class="line">    if (NOT HAVE_AVX2)</span><br><span class="line">        message(FATAL_ERROR &quot;AVX2 support required to build fat runtime&quot;)</span><br><span class="line">    endif ()</span><br><span class="line">    if (BUILD_AVX512 AND NOT HAVE_AVX512)</span><br><span class="line">        message(FATAL_ERROR &quot;AVX512 support requested but not supported&quot;)</span><br><span class="line">    endif ()</span><br><span class="line">else (NOT FAT_RUNTIME)</span><br><span class="line">    if (NOT HAVE_AVX2)</span><br><span class="line">        message(STATUS &quot;Building without AVX2 support&quot;)</span><br><span class="line">    endif ()</span><br><span class="line">    if (NOT HAVE_AVX512)</span><br><span class="line">        message(STATUS &quot;Building without AVX512 support&quot;)</span><br><span class="line">    endif ()</span><br><span class="line">#else (NOT FAT_RUNTIME)</span><br><span class="line">#    if (NOT HAVE_SSSE3)</span><br><span class="line">#        message(FATAL_ERROR &quot;A minimum of SSSE3 compiler support is required&quot;)</span><br><span class="line">#    endif ()</span><br><span class="line">endif ()</span><br></pre></td></tr></table></figure>
<p>注释掉上面的4行，否则编译不过</p>
<p>各种检查通过以后，会生成我们想要的make file，然后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -j 20</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>编译的过程是很慢的，可以喝杯茶等着。<br>最后在我们/opt里有的lib和include头文件，第三方用这个就可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/23/关于编译hyperscan/" data-id="cjn4dgo9t0011bklouf50vmhk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hyperscan编译/">hyperscan编译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx的配置管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/nginx的配置管理/" class="article-date">
  <time datetime="2017-05-10T11:26:32.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/nginx的配置管理/">nginx的配置管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>在介绍实现之前，我们先看一下，nginx的配置文件是如何管理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">user  nobody;</span><br><span class="line">daemon on;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/debug.log  debug;</span><br><span class="line"></span><br><span class="line">pid        run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#thread_pool default threads=64 max_queue=65536;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    multi_accept on;            #if on, accept as many connections as possible in one time</span><br><span class="line">    accept_mutex off;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile    on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    keepalive_requests 1000;</span><br><span class="line">    server &#123;</span><br><span class="line">        servername   www.test1.com</span><br><span class="line">        listen       80;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/test1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        servername   www.test2.com</span><br><span class="line">        listen       443;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/test2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致如上的样子，每一行都可以认为是一个command，有其参数。重要的是，每个指令有起生效范围。返回包含三类：</p>
<ul>
<li>NGX_HTTP_MAIN_CONF</li>
<li>NGX_HTTP_SRV_CONF</li>
<li>NGX_HTTP_LOC_CONF</li>
</ul>
<p>当我们写nginx插件的时候，会定义指令可以配置在哪个返回，举access_log为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;access_log&quot;),</span><br><span class="line">     NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF</span><br><span class="line">                       |NGX_HTTP_LMT_CONF|NGX_CONF_1MORE,</span><br><span class="line">     ngx_http_log_set_log,</span><br><span class="line">     NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">     0,</span><br><span class="line">     NULL &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这个指令即可以配置在main段可以server段也可以location段。而pid指令就只能配置在main段里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;pid&quot;),</span><br><span class="line">     NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,</span><br><span class="line">     ngx_conf_set_str_slot,</span><br><span class="line">     0,</span><br><span class="line">     offsetof(ngx_core_conf_t, pid),</span><br><span class="line">     NULL &#125;,</span><br></pre></td></tr></table></figure></p>
<p>在介绍实现之前，我们先李一个基本的规则，方便理解：</p>
<ul>
<li>main的实例只有一个，即全局的</li>
<li>server实例有很多个，存在于main内</li>
<li>location的实例有很多个，存在一个server内</li>
<li>每个模块在每个实例里都有自己的conf（当然在在那个实例里有其指令）</li>
</ul>
<p>好，后面就是我们的重点了，模块的配置到底是如何保存在各个实例中的（main实例，server实例，以及location实例）</p>
<h1 id="2-配置的管理"><a href="#2-配置的管理" class="headerlink" title="2.配置的管理"></a>2.配置的管理</h1><h2 id="2-1-模块的分类"><a href="#2-1-模块的分类" class="headerlink" title="2.1. 模块的分类"></a>2.1. 模块的分类</h2><p>nginx的模块，大致分两类吧，也许有别的，但我不关心</p>
<ul>
<li>CORE模块</li>
<li>HTTP模块</li>
</ul>
<p>core模块是最基础的模块，比如events模块,log模块，thread pool模块，http_core模块等，<br>HTTP模块是处理http时候使用的模块，我们增加的扩展大多属于这类模块。</p>
<p>CORE模块是第一层级，HTTP模块是http_core模块的下一层。这和配置管理很有关系。</p>
<h2 id="2-2-core模块的配置"><a href="#2-2-core模块的配置" class="headerlink" title="2.2. core模块的配置"></a>2.2. core模块的配置</h2><p>大家都知道nginx的配置，都保存在cycle-&gt;conf_ctx里，是一个void<em>**</em>类型，但为啥这么多层<em>，我现在仍不知情。<br>不过不影响我们看逻辑：他的第一层下标就是core模块的index，比如http_core模块的index是20，那么http_core模块对应的配置文件便是cycle-&gt;conf_ctx[20]，这样就脱调了一层</em>（我没看到哪里脱第二层和第三层）。</p>
<p>每个core模块的类型都是不一样的。先看个简单的名字为core的module，只是用于保存是否daemon on啊，pid怎么记录啊，core文件大小等信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                daemon;</span><br><span class="line">    ngx_flag_t                master;</span><br><span class="line"></span><br><span class="line">    ngx_msec_t                timer_resolution;</span><br><span class="line"></span><br><span class="line">    ngx_int_t                 worker_processes;</span><br><span class="line">    ngx_int_t                 debug_points;</span><br><span class="line"></span><br><span class="line">    ngx_int_t                 rlimit_nofile;</span><br><span class="line">    off_t                     rlimit_core;</span><br><span class="line"></span><br><span class="line">    int                       priority;</span><br><span class="line"></span><br><span class="line">    ngx_uint_t                cpu_affinity_auto;</span><br><span class="line">    ngx_uint_t                cpu_affinity_n;</span><br><span class="line">    ngx_cpuset_t             *cpu_affinity;</span><br><span class="line"></span><br><span class="line">    char                     *username;</span><br><span class="line">    ngx_uid_t                 user;</span><br><span class="line">    ngx_gid_t                 group;</span><br><span class="line"></span><br><span class="line">    ngx_str_t                 working_directory;</span><br><span class="line">    ngx_str_t                 lock_file;</span><br><span class="line"></span><br><span class="line">    ngx_str_t                 pid;</span><br><span class="line">    ngx_str_t                 oldpid;</span><br><span class="line"></span><br><span class="line">    ngx_array_t               env;</span><br><span class="line">    char                    **environment;</span><br><span class="line">&#125; ngx_core_conf_t;</span><br></pre></td></tr></table></figure></p>
<p>简单不是我们想要的，来个最复杂的，对于http_core模块来说，它的类型如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure></p>
<p>抽象的不要不要的，这也是我们要着重说的部分啦</p>
<h2 id="2-3-http-core的main"><a href="#2-3-http-core的main" class="headerlink" title="2.3 http_core的main"></a>2.3 http_core的main</h2><p>前面我们提到过，每个模块（此后我们说的都是http扩展模块哈）的指令可以定义在不同的范围生效，这里先介绍最简单的情况：在main里生效的情况。这也是最简单的情况了。这个和前面提到的core module的方式类似，是以数组的方式组织的，下标即http模块的下标。<br>从前面的代码，我们能从全局变量cycle-&gt;conf_ctx拿到http core模块的配置即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>main_conf,保留所有模块的main conf</li>
<li>srv_conf和loc_conf，看到这里的时候，敏感的人就会想，这里明明是main即全局的ctx，srv_conf和loc_conf会不会是没用的？答案是有用的，干啥用的，后面一起讲</li>
</ul>
<p>每个模块的main conf就保存在**main_conf里，比如access_log模块index是32，那么他的main conf就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ngx_http_conf_ctx_t*)(cycle-&gt;conf_ctx[http_core_module_index]))-&gt;main_conf[32];</span><br></pre></td></tr></table></figure>
<h2 id="2-4-http-core的server"><a href="#2-4-http-core的server" class="headerlink" title="2.4 http_core的server"></a>2.4 http_core的server</h2><p>模块的指令定义在server段的话，是保存在哪里呢？server实例不是全局唯一的，而是可以定义多个的，所以先需要知道server实例保存在哪里，进而知道如何在server实例里保存这个模块的配置。<br>找到了,它就在ngx_http_core_main_conf_t的servers成员里。servers是个数组，保存了所有server实例。</p>
<p>在2.3里，提到过main conf，他是每个模块的全局配置保存的地方，这里需要提一句的是：http_core模块是个内置的核心模块，它本身会有一些配置，但最重要的它维护了在本main 段的所有server实例。</p>
<p>那么server实例本身又是一个啥呢？你很眼熟，ngx_http_conf_ctx_t，前面有它的定义。那么这个家伙在这里又怎么理解呢？</p>
<ul>
<li>main_conf已经无用，因为这里已经是server段了</li>
<li>srv_conf保留了本实例里所有模块的server conf配置，以模块下标索引，类似之前的思路</li>
<li>loc_conf，和前面一样，这里是server段的ctx，那么loc_conf是不是没啥用，同样是有用的。</li>
</ul>
<h2 id="2-5-http-core的location"><a href="#2-5-http-core的location" class="headerlink" title="2.5 http_core的location"></a>2.5 http_core的location</h2><p>和前面的思路一样，我们需要知道location实例的窝藏点。<br>server实例们保存在ngx_http_core_main_conf_t里，那么location们按理应该保存在ngx_http_core_srv_conf_t里。<br>但失望了，它们确保存在ngx_http_core_loc_conf_t里。不美，但一定有原因，我不知道是为啥。（有人知道可以mail我qzzhou$126.com）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_queue_t  *locations;</span><br></pre></td></tr></table></figure>
<p>每个locations成员的类型是ngx_http_location_queue_t,具体怎么加入locations，请查阅代码ngx_http_add_location。<br>但ngx_http_location_queue_t只是一个封装，具体有逻辑的结构还是ngx_http_core_loc_conf_t。<br>ngx_http_core_loc_conf_t里有一个loc_conf的成员，答对了，他就是保存所有模块location配置的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* pointer to the modules&apos; loc_conf */</span><br><span class="line">void        **loc_conf;</span><br></pre></td></tr></table></figure></p>
<p>但location的实现着实不美丽啊，为啥不用ctx-&gt;loc_conf了呢，而是直接保存在ngx_http_core_loc_conf_t里呢？</p>
<p>我擦，我好像有点明白了，这个location所在的ngx_http_core_loc_conf_t不是 core http里的conf，而是它的父亲ctx即server的loc conf。（这句话你们肯定不懂）<br>因为前面提到过在server级别的ctx里，srv_conf和loc_conf是有意义的，locations的queue是保存在server ctx的location conf里。</p>
<h2 id="2-6-关于server和location实例的创建"><a href="#2-6-关于server和location实例的创建" class="headerlink" title="2.6 关于server和location实例的创建"></a>2.6 关于server和location实例的创建</h2><p>在遇到server{}和location{}后，会创建server实例和location实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static char * ngx_http_core_server(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)</span><br></pre></td></tr></table></figure>
<p>在创建server 实例的时候，实际上就是创建一个ngx_http_core_srv_conf_t，并为其成员ctx赋值<br>ctx的main_conf和全局的main_conf相等<br>然后为每个模块创建server_conf和location_conf。这样一个ctx就完整了</p>
<p>注意和前面呼应一下，server block里，还没有细化到location，创建了locatin_conf的用意是什么？因为毕竟location_conf要挂在一个location上嘛。</p>
<p>然后通过ngx_array_push(&amp;cmcf-&gt;servers); 添加一个ngx_http_core_srv_conf_t。</p>
<p>注意：我也是临时想到的，在解析文件过程中传递的一直是ngx_http_conf_ctx_t。但我们一直提到的实例是说ngx_http_core_srv_conf_t和ngx_http_core_main_conf_t这样的东西。别把解析和运行态搞混了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">static char *</span><br><span class="line">ngx_http_core_location(ngx_conf_t *cf, ngx_command_t *cmd, void *dummy)</span><br></pre></td></tr></table></figure>
<p>这个是创建location实例，实际上是创建一个ngx_http_core_loc_conf_t，但是是封装在ngx_http_location_queue_t里。</p>
<p>ngx_http_location_queue_t是queue的一个item，queue又挂在哪里呢？挂载这个location所在的server的core_http模块的loc_conf里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_core_srv_conf_t-&gt;ctx-&gt;loc_conf[http_core_module.index].locations</span><br></pre></td></tr></table></figure></p>
<p>因为locations只保存了一个地方，所以下面的地方就不一样了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_core_loc_conf_t-&gt;ctx-&gt;loc_conf[http_core_module.index].locations</span><br></pre></td></tr></table></figure>
<p>注意两片代码的层次不一样</p>
<h2 id="2-7-关于merge操作"><a href="#2-7-关于merge操作" class="headerlink" title="2.7 关于merge操作"></a>2.7 关于merge操作</h2><p>问题的起源是，如果一个选项比如access_log在main里和server各有配置，怎么办？模块的作者需要自己写merge函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static ngx_http_module_t  ngx_http_dyssl_module_ctx = &#123;</span><br><span class="line">    NULL,                             /* preconfiguration */</span><br><span class="line">    NULL,                             /* postconfiguration */</span><br><span class="line"></span><br><span class="line">    ngx_http_dyssl_create_main_conf,  /* create main configuration */</span><br><span class="line">    ngx_http_dyssl_init_main_conf,    /* init main configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                             /* create server configuration */</span><br><span class="line">    NULL,                             /* merge server configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                             /* create location configuration */</span><br><span class="line">    NULL                              /* merge location configuration */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么nginx是怎么回调用户自己的函数的呢？<br>而且互调的时候的参数类型是一样的，比如一个模块的作者定义了一条指令 xxx on/off。这个指令可以在不同范围生效。<br>对应不同段的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_loc_conf_t</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_srv_conf_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_main_conf_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>假设模块的作者想要的规则是使用最小范围的。location没配，则用server里的，server里没配，则用main里的。<br>当merge location的时候，传入的都是ngx_http_vdu_mapping_loc_conf_t类型的。我当时的困惑是，location里的配置当然是ngx_http_vdu_mapping_loc_conf_t类型的，但server哪里来ngx_http_vdu_mapping_loc_conf_t类型的配置。</p>
<p>再联想一下前面说的问题，为啥创建server实例的时候，会把各个模块的location实例创建出来一个，那时候分明还有没有解析到location配置。这个家伙就用用来merge的。那问题来了，他的enable的值从哪里来呢？当然是在server段里配置 xxx on/off的时候。<br>其实前面的类型定义的代码是错误的，<br>当一个指令可以在各个范围生效的时候，需要把这个指令存储在最小的范围里，所以上面的定义应该改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125; ngx_http_xxx_loc_conf_t</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125; ngx_http_xxx_srv_conf_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_main_conf_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后定义commands的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ngx_string(&quot;xxx&quot;),</span><br><span class="line">    NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONFNGX_CONF_FLAG,</span><br><span class="line">    ngx_conf_set_flag_slot,</span><br><span class="line">    NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">    offsetof(ngx_http_xxx_loc_conf_t, enable),</span><br><span class="line">    NULL</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>NGX_HTTP_LOC_CONF_OFFSET是告诉nginx，放到ctx的那个conf里，还记得ctx的定义么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure></p>
<p>然后offset那一行，告诉存储在那个变量里</p>
<p>最后关键来了，怎么merge呢？对于一个模块来说，就是用main实例里的srv_conf和server实例离的srv_conf merge，然后用server实例里的loc_conf和location实例离的loc_conf merge。</p>
<p>注意merge的时候是会改变配置的哦。</p>
<p>好了，分析结束，上一个大图。</p>
<p><img src="nginx_conf.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/10/nginx的配置管理/" data-id="cjn4dgo9o000qbklormze67tj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-openssl签发证书" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/05/openssl签发证书/" class="article-date">
  <time datetime="2017-05-05T09:05:30.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/05/openssl签发证书/">openssl签发证书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>为了搭建https的测试环境，还是别用自己的正式证书了，想自己当把CA，颁发一些证书，自己当根。网上看了一些文章，都是当前目录建立一个demoCA这样的东西，但使用openssl ca 命令的时候，总是各种访问默认目录/etc/pki什么的，所以hi是放弃幻想了。直接用系统的目录做事情吧。</p>
<p>先看一下这个目录的结构吧</p>
<pre>
    [root@cq01-bce-48-29-31.cq01.baidu.com httpsec]# tree /etc/pki/CA
        /etc/pki/CA
        |-- certs
        |-- crl
        |-- newcerts
        `-- private
    4 directories, 0 files
</pre>


<h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h1><h2 id="2-1-生成私钥"><a href="#2-1-生成私钥" class="headerlink" title="2.1.生成私钥"></a>2.1.生成私钥</h2><p>进入CA目录，生成我们的一个私钥：</p>
<pre>
    cd /etc/pki/CA
    openssl genrsa -out private/cakey.pem 2048
</pre>

<p>大家可能问，公钥跑哪里去了，实际上生成的私钥里既有私钥，也有一些基础信息，用于将来生成公钥</p>
<pre>
    RSAPrivateKey ::= SEQUENCE {
        version Version,
        modulus INTEGER, -- n
        publicExponent INTEGER, -- e
        privateExponent INTEGER, -- d
        prime1 INTEGER, -- p
        prime2 INTEGER, -- q
        exponent1 INTEGER, -- d mod (p-1)
        exponent2 INTEGER, -- d mod (q-1)
        coefficient INTEGER, -- (inverse of q) mod p
        otherPrimeInfos OtherPrimeInfos OPTIONAL
    }

    RSAPublicKey ::= SEQUENCE {
        modulus INTEGER, -- n
        publicExponent INTEGER -- e
    }
</pre>


<h2 id="2-2-生成根证书"><a href="#2-2-生成根证书" class="headerlink" title="2.2.生成根证书"></a>2.2.生成根证书</h2><p>生成根证书有两种方式，一种是直接生成字签名根证书，一种是先生成根证书的请求文件csr，然后自己跟自己颁根证书</p>
<p>方法一</p>
<pre>
    openssl req -new -days 3650 -x509 -key ./private/cakey.pem -out  cacert.pem
</pre>


<p>方法二</p>
<pre>
    openssl req -new -key ./private/cakey.pem -out  rootca.csr
    openssl req -x509 -days 3650 -key ./private/cakey.pem -in rootca.csr -out cacert.pem
</pre>

<p>我们可以看下证书的内容</p>
<pre>
     openssl x509 -in rootca.crt -noout -text
</pre>



<h2 id="2-4-给别人签发证书"><a href="#2-4-给别人签发证书" class="headerlink" title="2.4.给别人签发证书"></a>2.4.给别人签发证书</h2><p>自己当了CA后，就可以给别人签发证书了。客户自己生成一个证书请求，给CA，CA就可以生成证书了</p>
<p>在客户机执行如下操作</p>
<pre>
    1.生成私钥
    openssl genrsa -out client1_key.pem 2048
    openssl  req -new -key  client1_key.pem  -out client1.csr
</pre>

<p>最后就是关键的 一步，签发证书,表示CA对证书申请者的认同。</p>
<pre>
    openssl ca -in client1.csr -out client1.pem
</pre>

<p>中间可能会提示index.txt文件和serial文件，按他的要求有这个两个文件即可，也可以一开始的时候就初始化好</p>
<pre>
    touch /etc/pki/CA/index.txt
    echo xyz > /etc/pki/CA/serial
</pre>

<p>好了，搞定！</p>
<p>期间需要注意的是，root CA的证书申请时候的Country,State,Comm那几个字段要一致，否则签发不了证书。可以自己试试。</p>
<p>补一个，证书导出公钥</p>
<pre>
openssl x509 -inform PEM -in client1.pem -outform PEM -pubkey -noout
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/05/openssl签发证书/" data-id="cjn4dgo9q000vbkloz7qdlz1v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CC防护，nginx，封禁/">CC防护，nginx，封禁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RSA加密/">RSA加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegEx/">RegEx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSL/">SSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/emacs/">emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flow-table/">flow-table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo使用/">hexo使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperscan/">hyperscan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperscan编译/">hyperscan编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/intel/">intel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/neutron/">neutron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openvswitch/">openvswitch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ovs/">ovs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resolve/">resolve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upstream/">upstream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字节序/">字节序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全组/">安全组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游记/">游记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络字节序，主机字节序/">网络字节序，主机字节序</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CC防护，nginx，封禁/" style="font-size: 10px;">CC防护，nginx，封禁</a> <a href="/tags/RSA加密/" style="font-size: 10px;">RSA加密</a> <a href="/tags/RegEx/" style="font-size: 10px;">RegEx</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/emacs/" style="font-size: 10px;">emacs</a> <a href="/tags/flow-table/" style="font-size: 10px;">flow-table</a> <a href="/tags/hexo使用/" style="font-size: 10px;">hexo使用</a> <a href="/tags/hyperscan/" style="font-size: 10px;">hyperscan</a> <a href="/tags/hyperscan编译/" style="font-size: 10px;">hyperscan编译</a> <a href="/tags/intel/" style="font-size: 10px;">intel</a> <a href="/tags/neutron/" style="font-size: 20px;">neutron</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/openvswitch/" style="font-size: 10px;">openvswitch</a> <a href="/tags/ovs/" style="font-size: 10px;">ovs</a> <a href="/tags/resolve/" style="font-size: 10px;">resolve</a> <a href="/tags/upstream/" style="font-size: 10px;">upstream</a> <a href="/tags/字节序/" style="font-size: 10px;">字节序</a> <a href="/tags/安全组/" style="font-size: 10px;">安全组</a> <a href="/tags/游记/" style="font-size: 10px;">游记</a> <a href="/tags/网络字节序，主机字节序/" style="font-size: 10px;">网络字节序，主机字节序</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/26/理解字节序/">理解字节序</a>
          </li>
        
          <li>
            <a href="/2018/02/14/a-out的幕后/">a.out的幕后</a>
          </li>
        
          <li>
            <a href="/2018/01/31/RSA算法证明/">RSA算法证明</a>
          </li>
        
          <li>
            <a href="/2018/01/05/SSL基础知识总结/">SSL基础知识总结</a>
          </li>
        
          <li>
            <a href="/2017/12/15/nginx实现动态resolve的思路/">nginx实现动态resolve的思路</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 abonege<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>