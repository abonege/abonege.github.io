<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>也来说说Neutron的组件及其RPC通讯 | 秋月春风等闲度,暮去朝来颜色故</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">也来说说Neutron的组件及其RPC通讯</h1><a id="logo" href="/.">秋月春风等闲度,暮去朝来颜色故</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">也来说说Neutron的组件及其RPC通讯</h1><div class="post-meta">May 18, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h1 id="1-Neutron中的各个角色"><a href="#1-Neutron中的各个角色" class="headerlink" title="1.Neutron中的各个角色"></a>1.Neutron中的各个角色</h1><p>Neutron虽然只是OpenStack中的一个角色，网络，但已经足够复杂，它内部又有很多概念。（这些概念在其他的openstack角色之间也是通用的），初学者动不动就被吓得体无完肤，挣扎了近一个月，饱经摧残，真相总算渐渐浮出水面，谢谢那些帮助我的老员工，在KPI压力很大的情况下，依然抽出时间回答我的问题，bless。</p>
<p>Neutron可以认为是一个中心，四周插件遍地扩展的结构，中心是Core Plugin，扩展（Extention）呢，就是单独完成独立功能的一个个组件，比如负载均衡LBaaS，防火墙FWaaS之类的。他们都是以扩展的方式嵌在Core Plugin的周围。</p>
<h2 id="1-1-Neutron的基础"><a href="#1-1-Neutron的基础" class="headerlink" title="1.1.Neutron的基础"></a>1.1.Neutron的基础</h2><p>先回答个问题：Neutron的最最基础的功能是什么呢？<br>管理网络，再基础一点呢？管理二层网络。没错是二层网络，所以Neutron管理的核心3大件是：Port，Network，和Subnet。至于路由，dhcp，负载均衡，防火墙都是上层的扩展。</p>
<h2 id="1-2-Neutron-Server"><a href="#1-2-Neutron-Server" class="headerlink" title="1.2.Neutron Server"></a>1.2.Neutron Server</h2><p>我们要介绍的第一个大角色，Neutron Server是一个实体，是一个（组）实实在在进程，它的任务这么几个：</p>
<ul>
<li>接受API过来的指令，比如创建一个network，删除一个router等等</li>
<li>通过RPC和各个Agent通讯</li>
<li>调度，比如一个网络的2个DHCP Agent，应该调度在那些网络节点上</li>
<li>对插件的管理和使用。Neutron本身可以很简单，但为了支持复杂的功能，可以通过扩展不断的添加再添加</li>
</ul>
<h2 id="1-3-AMQP"><a href="#1-3-AMQP" class="headerlink" title="1.3.AMQP"></a>1.3.AMQP</h2><p>AMQP，全称是啥？Advanced Message Queue Protocol? 也许吧，反正就是一种协议，规定了不同角色之间传递消息的格式是什么。有很多实现了AMQP协议的开源方案，我们这里用的是QPID，QPID也是一组进程，它的职责就是收到一个消息后路由给响应的对象，大家可以看<a href="https://www.ibm.com/developerworks/cn/cloud/library/1403_renmm_opestackrpc/" target="_blank" rel="noopener">Openstack RPC 通信原理</a>。</p>
<h2 id="1-4-ML2"><a href="#1-4-ML2" class="headerlink" title="1.4.ML2"></a>1.4.ML2</h2><p>最著名，最基础的plugin，也就是core plugin。抽象出来一层逻辑，屏蔽下层复杂的的二层网络，flat，vxlan，gre之类的，都抽象成对上面3个基础组件的管理，port，network，以及subnet。</p>
<h2 id="Service-与-Plugin"><a href="#Service-与-Plugin" class="headerlink" title="Service 与 Plugin"></a>Service 与 Plugin</h2><p>我理了好久关于Neutron里各个概念的意思，也看到过云耳的一片博客<a href="http://www.cnblogs.com/zhutianshi/p/3902315.html" target="_blank" rel="noopener">如何区分 OpenStack Neutron Extension 和 Plugin</a><br>但我觉得他理解的还是不对。我的理解是这样的：<br>从最基础的管理角度来说，core plugin管理最基础的网络组件Port,Network和Subnet。当有更丰富的网络功能需要填充的时候，比如lbaas,fwaas,vpnaas等，这些功能不是很核心，然后怎么办呢，它们是以service的方式扩展出来的。<br>我更觉得Core Plugin应该改名字为Core Serivce。<br>一个标准的Service包含4个大件：</p>
<ul>
<li>Plugin. 该逻辑在Neutron Server里的实现，包含操作数据库</li>
<li>Agent.  该逻辑在网络节点的代码，接受Neutron Server的指令</li>
<li>Driver. 在Agent端驱动数据流</li>
<li>调度.    调度给哪个Agent处理</li>
</ul>
<h2 id="1-5-Extention"><a href="#1-5-Extention" class="headerlink" title="1.5.Extention"></a>1.5.Extention</h2><p>终于提到了扩展，扩展是对Core Plugin和Service的扩充，比如，对调度模块增加一种算法，比如network需要增加一个多AZ属性等，都需要通过Extention来实现，那问了，为啥不是直接该调度和network结构呢？<br>显然么，作为一个被普遍使用的产品要考虑升级的兼容性，虽然升了级，但不想用这个extention，不夹在这个extentions即可。<br>使用下面的命令，可以看当前的neutron开启了哪些扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">neutron@mynet-206-215-44 ~ $ neutron ext-list</span><br><span class="line">+-----------------------+-----------------------------------------------+</span><br><span class="line">| alias                 | name                                          |</span><br><span class="line">+-----------------------+-----------------------------------------------+</span><br><span class="line">| ext-gw-mode           | Neutron L3 Configurable external gateway mode |</span><br><span class="line">| security-group        | security-group                                |</span><br><span class="line">| l3_agent_scheduler    | L3 Agent Scheduler                            |</span><br><span class="line">| fwaas                 | Firewall service                              |</span><br><span class="line">| binding               | Port Binding                                  |</span><br><span class="line">| provider              | Provider Network                              |</span><br><span class="line">| agent                 | agent                                         |</span><br><span class="line">| quotas                | Quota management support                      |</span><br><span class="line">| dhcp_agent_scheduler  | DHCP Agent Scheduler                          |</span><br><span class="line">| l2pop_fdb_entries     | l2pop_fdb_entries                             |</span><br><span class="line">| multi-provider        | Multi Provider Network                        |</span><br><span class="line">| external-net          | Neutron external network                      |</span><br><span class="line">| router                | Neutron L3 Router                             |</span><br><span class="line">| allowed-address-pairs | Allowed Address Pairs                         |</span><br><span class="line">| extra_dhcp_opt        | Neutron Extra DHCP opts                       |</span><br><span class="line">| extraroute            | Neutron Extra Route                           |</span><br><span class="line">+-----------------------+-----------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>我个人认为扩展是针对功能说的，一个extention支持一个或几个功能，但从软件的角度讲，扩展包括下面几个部分：</p>
<h3 id="1-5-1-Agent"><a href="#1-5-1-Agent" class="headerlink" title="1.5.1.Agent"></a>1.5.1.Agent</h3><p>Agent是相对于Neutron Server的，一般管Nentron Server所在的点叫控制节点，Agent所在的节点为网络节点，虚拟机所在的节点为计算节点。<br>Agent是干嘛用的呢，字面意思就能看出来，向Agent所在的机器执行neutron server发过来的指令，在有必要的情况下也向neutorn server反馈一些信息。</p>
<h3 id="1-5-2-Plugin"><a href="#1-5-2-Plugin" class="headerlink" title="1.5.2.Plugin"></a>1.5.2.Plugin</h3><p>了解了Agent后，Plugin就轻松一些了，Plugin可以认为是Agent在Neutron Server端的逻辑，因为Neutorn是插件化的东西，比如想基于neutron开发一个功能负载均衡，需要在neutron server端和agent端各自实现负载均衡的逻辑，要不然只在Agent端实现了，neutron server这边不知道具体逻辑是什么，怎么通讯呢？<br>此外，Plugin还有一个很重要的功能，就是读写数据库，因为一般一个功能都需要读写数据库。</p>
<h3 id="1-5-3-Driver"><a href="#1-5-3-Driver" class="headerlink" title="1.5.3.Driver"></a>1.5.3.Driver</h3><p>Extention的Driver基本上是和Agent在一起的，一个进程里包含这2个部分。Agent主要负责和Neutron Server(plugin)的交互，而driver呢，主要用于实现对该extention的数据平面对应的管理平面的配置。<br>说的有点绕啊，举个例子就明白了:<br>比如你想用haproxy实现一个负载均衡的扩展，LBAgent用于从Neutron Server接受创建/销毁 负载均衡实例的请求，然后告诉driver处理，driver干什么呢？就是生成haproxy的配置文件，然后启动一个haproxy的进程来加载配置文件。<br>所以Driver还是只是管理平面的一个东西。</p>
<h1 id="2-Neutron角色之间的的RPC通讯"><a href="#2-Neutron角色之间的的RPC通讯" class="headerlink" title="2.Neutron角色之间的的RPC通讯"></a>2.Neutron角色之间的的RPC通讯</h1><h2 id="2-1-RPC是什么"><a href="#2-1-RPC是什么" class="headerlink" title="2.1.RPC是什么"></a>2.1.RPC是什么</h2><p>好，基本概念介绍完了后，我们可以开始我们的主题了，那就是RPC通讯，一般来讲，RPC通讯就是Agent和Plugin的通讯，或者说是Agent和Neutron Server的通讯，其实Plugin本身对外只提供函数，从AMQP消息翻译成对应的Plugin里的函数的操作已经在Neutron Server里完成了。所以基本上就是Agent发一个消息，Plugin里就有一个函数被调用了，我们这些主要想弄清它们是怎么关联的。</p>
<h2 id="2-2-基本规则"><a href="#2-2-基本规则" class="headerlink" title="2.2.基本规则"></a>2.2.基本规则</h2><p>通讯分2端，一般我们把主动发起的这段叫客户端，另一端为server端。RPC也分2个方向上的通讯，从Agent到Neutron Server和反过来的。</p>
<h3 id="2-2-1-客户端"><a href="#2-2-1-客户端" class="headerlink" title="2.2.1.客户端"></a>2.2.1.客户端</h3><p>客户端都是通过继承RpcProxy来实现，这个类不能直接找到，在rpc_inner目录里的proxy.py。 派生类的命名方式都是XxxxApi的格式。<br>然后还可以细化成两类：</p>
<ul>
<li>XxxPluginXxxApi: 这类基本上都是Agent发起的对Plugin的调用，在Agent端封装发送消息，在Plugin端实现动作。</li>
<li>XxxNotifierApi: 这类基本上是在Plugin（Neutron Server）封装发送消息，在Agent端实现动作。<br>客户端继承了这些Api，只是发送出来消息而已，需要在Server端实现对应的动作，可以简单的看一点代码：<br>比如DHCP Agent想为一个用户启动一个服务dnsmasq的时候，需要先创建一个port，但这个port自己创建不了，需要通知neutron server，然后通过openvswitch来做，这个在DhcpPluginApi是这么干的：<figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class DhcpPluginApi(proxy.RpcProxy):</span><br><span class="line">    def create_dhcp_port(self, port):</span><br><span class="line">        &quot;&quot;&quot;Make a remote process call to create the dhcp port.&quot;&quot;&quot;</span><br><span class="line">        port = self.call(self.context,</span><br><span class="line">                         self.make_msg(&apos;create_dhcp_port&apos;,</span><br><span class="line">                                       port=port,</span><br><span class="line">                                       host=self.host),</span><br><span class="line">                         topic=self.topic)</span><br><span class="line">        if port:</span><br><span class="line">            return dhcp.DictModel(port)</span><br></pre></td></tr></table></figure>
所以它只是从客户端的角度发出来一个msg而已。<h3 id="2-2-2-服务端"><a href="#2-2-2-服务端" class="headerlink" title="2.2.2.服务端"></a>2.2.2.服务端</h3>上面提到过客户端是怎么干的，那么服务端怎么找到对应的逻辑呢，我们虽然不需要知道，怎么从msg翻译成函数的，但需要知道在Neuron端如何实现相应的逻辑：</li>
<li>Neutron Server作为服务端<br>在这里也有类似的命名规则：<br>通常实现逻辑的类都叫XxxRpcCallback，或者后面有个Mixin，XxxRpcCallbackMixin，比如上面的dhcp的例子，在Neutron Server里，会有一个类DhcpRpcCallbackMixin里实现一个create_dhcp_port的功能。</li>
</ul>
<p>那么这次callback是怎么注册的呢？让Neutron Server知道这个消息来了，该谁处理。<br>通常callback是plugin的一部分，plugin初始化的时候，会创建consumer，并说我关注哪些topic。比如Ml2Plugin是这么干的：<br><figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def start_rpc_listener(self):</span><br><span class="line">    self.callbacks = rpc.RpcCallbacks(self.notifier, self.type_manager)</span><br><span class="line">    self.topic = topics.PLUGIN</span><br><span class="line">    self.conn = c_rpc.create_connection(new=True)</span><br><span class="line">    self.dispatcher = self.callbacks.create_rpc_dispatcher()</span><br><span class="line">    self.conn.create_consumer(self.topic, self.dispatcher,</span><br><span class="line">                              fanout=False)</span><br><span class="line">    return self.conn.consume_in_thread()</span><br></pre></td></tr></table></figure><br>上面是说这个callback关心PLUGIN topic</p>
<p>而openvswitch的plugin是这么干的：<br><figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def setup_rpc(self):</span><br><span class="line">    # RPC support</span><br><span class="line">    self.service_topics = &#123;svc_constants.CORE: topics.PLUGIN,</span><br><span class="line">                           svc_constants.L3_ROUTER_NAT: topics.L3PLUGIN&#125;</span><br><span class="line">    self.conn = rpc.create_connection(new=True)</span><br><span class="line">    self.notifier = AgentNotifierApi(topics.AGENT)</span><br><span class="line">    self.agent_notifiers[q_const.AGENT_TYPE_DHCP] = (</span><br><span class="line">        dhcp_rpc_agent_api.DhcpAgentNotifyAPI()</span><br><span class="line">    )</span><br><span class="line">    self.agent_notifiers[q_const.AGENT_TYPE_L3] = (</span><br><span class="line">        l3_rpc_agent_api.L3AgentNotify</span><br><span class="line">    )</span><br><span class="line">    self.callbacks = OVSRpcCallbacks(self.notifier, self.tunnel_type)</span><br><span class="line">    self.dispatcher = self.callbacks.create_rpc_dispatcher()</span><br><span class="line">    for svc_topic in self.service_topics.values():</span><br><span class="line">        self.conn.create_consumer(svc_topic, self.dispatcher, fanout=False)</span><br><span class="line">    # Consume from all consumers in a thread</span><br><span class="line">    self.conn.consume_in_thread()</span><br></pre></td></tr></table></figure><br>上面是说这个callback关心那2个topic，即PLUGIN和L3PLUGIN<br>所以来一个msg后，先找配置的TOPIC的consumer，然后根据消息的名字，找处理函数。</p>
<ul>
<li>Agent作为服务端<br>此外还有另一个方向的，即Neutron Server要向Agent广播消息，比如一个port创建了，需要告诉所有的OVSAgent，干嘛干嘛。<br>这时候Neutron Server这端，是通过继承NotifierAPI来通知的，然后这时候Server端就是Agent端了。<br>那么Agent端怎么做才能收到，处理这些消息呢？2种方式：<br><strong>继承RpcCallback方式</strong><br>这个方式和Neutron Server端的实现一样，继承某某RpcCallback函数，然后在初始化的时候创建consumer。OVSNeutronAgent就这么干的<figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class OVSNeutronAgent(sg_rpc.SecurityGroupAgentRpcCallbackMixin,</span><br><span class="line">                      l2population_rpc.L2populationRpcCallBackMixin):</span><br></pre></td></tr></table></figure>
<strong>Service的方式</strong><br>不需要继承RpcCallback函数，但需要实现一样的逻辑函数，然后通过neutron_service.Service.create来创建一个Service，这个Service会根据收到的消息，调用你的实现函数，DHCPAgent就这么干的。<figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server = neutron_service.Service.create(</span><br><span class="line">    binary=&apos;neutron-dhcp-agent&apos;,</span><br><span class="line">    topic=topics.DHCP_AGENT,</span><br><span class="line">    report_interval=cfg.CONF.AGENT.report_interval,</span><br><span class="line">    manager=&apos;neutron.agent.dhcp_agent.DhcpAgentWithStateReport&apos;)</span><br></pre></td></tr></table></figure>
DhcpAgentWithStateReport是DHCPAgent的实现类，里面有callback函数，比如network_create_end, networkd_delete_end等。</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://abonege.github.io/2016/05/18/Neutron组件的RPC通讯/" data-id="cjq7qe7d400034jlo8hu1a1vw" class="article-share-link">分享到</a><div class="tags"><a href="/tags/neutron/">neutron</a></div><div class="post-nav"><a href="/2016/05/25/如何在hexo使用图片/" class="pre">如何在hexo使用图片和提供附件下载</a><a href="/2016/05/05/在neutron数据库增加一个列/" class="next">在neutron数据库增加一个列</a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://abonege.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/RegEx/" style="font-size: 15px;">RegEx</a> <a href="/tags/neutron/" style="font-size: 15px;">neutron</a> <a href="/tags/安全组/" style="font-size: 15px;">安全组</a> <a href="/tags/RSA加密/" style="font-size: 15px;">RSA加密</a> <a href="/tags/openssl/" style="font-size: 15px;">openssl</a> <a href="/tags/SSL/" style="font-size: 15px;">SSL</a> <a href="/tags/emacs/" style="font-size: 15px;">emacs</a> <a href="/tags/CC防护，nginx，封禁/" style="font-size: 15px;">CC防护，nginx，封禁</a> <a href="/tags/hyperscan/" style="font-size: 15px;">hyperscan</a> <a href="/tags/intel/" style="font-size: 15px;">intel</a> <a href="/tags/flow-table/" style="font-size: 15px;">flow-table</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/upstream/" style="font-size: 15px;">upstream</a> <a href="/tags/resolve/" style="font-size: 15px;">resolve</a> <a href="/tags/hyperscan编译/" style="font-size: 15px;">hyperscan编译</a> <a href="/tags/ovs/" style="font-size: 15px;">ovs</a> <a href="/tags/openvswitch/" style="font-size: 15px;">openvswitch</a> <a href="/tags/hexo使用/" style="font-size: 15px;">hexo使用</a> <a href="/tags/字节序/" style="font-size: 15px;">字节序</a> <a href="/tags/网络字节序，主机字节序/" style="font-size: 15px;">网络字节序，主机字节序</a> <a href="/tags/游记/" style="font-size: 15px;">游记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/26/理解字节序/">理解字节序</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/14/a-out的幕后/">a.out的幕后</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/RSA算法证明/">RSA算法证明</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/05/SSL基础知识总结/">SSL基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/15/nginx实现动态resolve的思路/">nginx实现动态resolve的思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/07/nginx上支持手工封禁请求的的思路/">nginx上支持手工封禁请求的的思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/hyperscan使用/">hyperscan使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/关于编译hyperscan/">关于编译hyperscan</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/nginx的配置管理/">nginx的配置管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/openssl签发证书/">openssl签发证书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://baidjia.baidu.com" title="百度百家" target="_blank">百度百家</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">秋月春风等闲度,暮去朝来颜色故.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>