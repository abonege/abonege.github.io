<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>秋月春风等闲度,暮去朝来颜色故</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="秋月春风等闲度,暮去朝来颜色故">
<meta property="og:url" content="http://abonege.github.io/page/2/index.html">
<meta property="og:site_name" content="秋月春风等闲度,暮去朝来颜色故">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋月春风等闲度,暮去朝来颜色故">
  
    <link rel="alternate" href="/atom.xml" title="秋月春风等闲度,暮去朝来颜色故" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">秋月春风等闲度,暮去朝来颜色故</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://abonege.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-nginx的配置管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/nginx的配置管理/" class="article-date">
  <time datetime="2017-05-10T11:26:32.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/nginx的配置管理/">nginx的配置管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>在介绍实现之前，我们先看一下，nginx的配置文件是如何管理的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">user  nobody;</span><br><span class="line">daemon on;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/debug.log  debug;</span><br><span class="line"></span><br><span class="line">pid        run/nginx.pid;</span><br><span class="line"></span><br><span class="line">#thread_pool default threads=64 max_queue=65536;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">    multi_accept on;            #if on, accept as many connections as possible in one time</span><br><span class="line">    accept_mutex off;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile    on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    keepalive_requests 1000;</span><br><span class="line">    server &#123;</span><br><span class="line">        servername   www.test1.com</span><br><span class="line">        listen       80;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/test1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        servername   www.test2.com</span><br><span class="line">        listen       443;</span><br><span class="line">        access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/test2;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致如上的样子，每一行都可以认为是一个command，有其参数。重要的是，每个指令有起生效范围。返回包含三类：</p>
<ul>
<li>NGX_HTTP_MAIN_CONF</li>
<li>NGX_HTTP_SRV_CONF</li>
<li>NGX_HTTP_LOC_CONF</li>
</ul>
<p>当我们写nginx插件的时候，会定义指令可以配置在哪个返回，举access_log为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;access_log&quot;),</span><br><span class="line">     NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF</span><br><span class="line">                       |NGX_HTTP_LMT_CONF|NGX_CONF_1MORE,</span><br><span class="line">     ngx_http_log_set_log,</span><br><span class="line">     NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">     0,</span><br><span class="line">     NULL &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，这个指令即可以配置在main段可以server段也可以location段。而pid指令就只能配置在main段里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;pid&quot;),</span><br><span class="line">     NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,</span><br><span class="line">     ngx_conf_set_str_slot,</span><br><span class="line">     0,</span><br><span class="line">     offsetof(ngx_core_conf_t, pid),</span><br><span class="line">     NULL &#125;,</span><br></pre></td></tr></table></figure></p>
<p>在介绍实现之前，我们先理一个基本的规则，方便理解：</p>
<ul>
<li>main的实例只有一个，即全局的</li>
<li>server实例有很多个，存在于main内</li>
<li>location的实例有很多个，存在一个server内</li>
<li>每个模块在可以有若干配置指令，指令的生效范围可以是前面的3个实例</li>
</ul>
<p>好，后面就是我们的重点了，模块的配置到底是如何保存在各个实例中的（main实例，server实例，以及location实例）</p>
<h1 id="2-配置的管理"><a href="#2-配置的管理" class="headerlink" title="2.配置的管理"></a>2.配置的管理</h1><h2 id="2-1-模块的分类"><a href="#2-1-模块的分类" class="headerlink" title="2.1. 模块的分类"></a>2.1. 模块的分类</h2><p>nginx的模块，大致分两类吧，也许有别的，但我不关心</p>
<ul>
<li>CORE模块</li>
<li>HTTP模块</li>
</ul>
<p>core模块是最基础的模块，比如events模块,log模块，thread pool模块，http_core模块等，<br>HTTP模块是处理http时候使用的模块，我们增加的扩展大多属于这类模块。</p>
<p>CORE模块是第一层级，HTTP模块是http_core模块的下一层。这和配置管理很有关系。</p>
<h2 id="2-2-core模块的配置"><a href="#2-2-core模块的配置" class="headerlink" title="2.2. core模块的配置"></a>2.2. core模块的配置</h2><p>大家都知道nginx的配置，都保存在cycle-&gt;conf_ctx里，是一个void<em>**</em>类型，但为啥这么多层<em>，我现在仍不知情。<br>不过不影响我们看逻辑：他的第一层下标就是core模块的index，比如http_core模块的index是20，那么http_core模块对应的配置文件便是cycle-&gt;conf_ctx[20]，这样就脱调了一层</em>（我没看到哪里脱第二层和第三层）。<br>core 模块有这么几个</p>
<ul>
<li>ngx_core_module </li>
<li>ngx_events_module</li>
<li>ngx_openssl_module</li>
<li>ngx_google_perftools_module</li>
<li>ngx_http_module</li>
<li>ngx_errlog_module</li>
<li>ngx_mail_module</li>
<li>ngx_regex_module</li>
<li>ngx_stream_module</li>
<li>ngx_thread_pool_module</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">变量名</th>
<th style="text-align:left">模块名</th>
<th style="text-align:left">配置文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ngx_core_module</td>
<td style="text-align:left">core</td>
<td style="text-align:left">ngx_core_conf_t</td>
</tr>
<tr>
<td style="text-align:left">ngx_http_module</td>
<td style="text-align:left">http</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">ngx_stream_module</td>
<td style="text-align:left">stream</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">ngx_google_perftools_module</td>
<td style="text-align:left">google_perftools</td>
<td style="text-align:left">ngx_google_perftools_conf_t</td>
</tr>
<tr>
<td style="text-align:left">ngx_events_module</td>
<td style="text-align:left">events</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">ngx_errlog_module</td>
<td style="text-align:left">errlog</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">ngx_mail_module</td>
<td style="text-align:left">mail</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">ngx_regex_module</td>
<td style="text-align:left">regex</td>
<td style="text-align:left">ngx_regex_conf_t</td>
</tr>
<tr>
<td style="text-align:left">ngx_openssl_module</td>
<td style="text-align:left">openssl</td>
<td style="text-align:left">ngx_openssl_conf_t</td>
</tr>
<tr>
<td style="text-align:left">ngx_thread_pool_module</td>
<td style="text-align:left">thread_pool</td>
<td style="text-align:left">ngx_thread_pool_conf_t</td>
</tr>
</tbody>
</table>
<p>core module的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_str_t             name;</span><br><span class="line">    void               *(*create_conf)(ngx_cycle_t *cycle);</span><br><span class="line">    char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);</span><br><span class="line">&#125; ngx_core_module_t;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，有的是create_conf是有值的，比如mail/regex/thread_pool/core，其他的是没有的，为什么会有这样的分别呢?<br>我们可以看看core这个module得conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                daemon;</span><br><span class="line">    ngx_flag_t                master;</span><br><span class="line"></span><br><span class="line">    ngx_msec_t                timer_resolution;</span><br><span class="line"></span><br><span class="line">    ngx_int_t                 worker_processes;</span><br><span class="line">    ngx_int_t                 debug_points;</span><br><span class="line"></span><br><span class="line">    ngx_int_t                 rlimit_nofile;</span><br><span class="line">    off_t                     rlimit_core;</span><br><span class="line"></span><br><span class="line">    int                       priority;</span><br><span class="line"></span><br><span class="line">    ngx_uint_t                cpu_affinity_auto;</span><br><span class="line">    ngx_uint_t                cpu_affinity_n;</span><br><span class="line">    ngx_cpuset_t             *cpu_affinity;</span><br><span class="line"></span><br><span class="line">    char                     *username;</span><br><span class="line">    ngx_uid_t                 user;</span><br><span class="line">    ngx_gid_t                 group;</span><br><span class="line"></span><br><span class="line">    ngx_str_t                 working_directory;</span><br><span class="line">    ngx_str_t                 lock_file;</span><br><span class="line"></span><br><span class="line">    ngx_str_t                 pid;</span><br><span class="line">    ngx_str_t                 oldpid;</span><br><span class="line"></span><br><span class="line">    ngx_array_t               env;</span><br><span class="line">    char                    **environment;</span><br><span class="line">&#125; ngx_core_conf_t;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，里边都是一些全局的配置，比如是否daemon，pid等等。都很直接。</p>
<p>那么为什么其他的模块，比如event/http/stream 都没有对应的conf呢？<br>因为http/stream 可以有多个，每个http和stream，还有其更细分的模块，不再是NGX_CORE_MODULE这个类型了。<br>比如：</p>
<ul>
<li>http有一个对应ngx_http_core_module，其类型为NGX_HTTP_MODULE</li>
<li>stream有一个对应的ngx_stream_core_module，其类型为NGX_STREAM_MODULE</li>
<li>event有一个对应的ngx_event_core_module，其对应的类型为NGX_EVENT_MODULE</li>
</ul>
<p>这里errlog是一个另类，欠一个债，后续补充</p>
<p>对于一个新增的模块，一般需要写很一些配置命令，这些配置命令有的是通过set_slot的方式写入到main/svc/loc的配置conf中，有的是调用函数。<br>调用函数的格式一般这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char *</span><br><span class="line">ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)</span><br></pre></td></tr></table></figure>
<p>cf和conf 是什么呢？这个对于理解配置文件解析是很重要的<br>先说ngx_conf_t，这个是本命令所在实例（main/srv/loc）的总体配置情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_conf_s &#123;</span><br><span class="line">    char                 *name;        //命令的名字</span><br><span class="line">    ngx_array_t          *args;        //命令的参数</span><br><span class="line"></span><br><span class="line">    ngx_cycle_t          *cycle;</span><br><span class="line">    ngx_pool_t           *pool;</span><br><span class="line">    ngx_pool_t           *temp_pool;</span><br><span class="line">    ngx_conf_file_t      *conf_file;</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line"></span><br><span class="line">    void                 *ctx;         // 最重要的部分</span><br><span class="line">    ngx_uint_t            module_type;</span><br><span class="line">    ngx_uint_t            cmd_type;</span><br><span class="line"></span><br><span class="line">    ngx_conf_handler_pt   handler;</span><br><span class="line">    void                 *handler_conf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ctx是最重要的部分，他是本command所在的实例的上下文信息，对于不通的模块，结构不太一样<br>对于http来讲，其为ngx_http_conf_ctx_t。在一个http{},sever{},location{}开始的时候，都会创建一个这样的变量，{}内的命令解析的时候的cf就是这个变量<br>对于event来讲，其为一个数组指针<br>对于stream来讲，是ngx_stream_conf_ctx_t</p>
<p>那参数conf又是啥呢？在某个实例内，解析到某个命令的时候，conf是该命令所在模块在这个实例的配置。<br>比如listen命令定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; ngx_string(&quot;listen&quot;),</span><br><span class="line">  NGX_HTTP_SRV_CONF|NGX_CONF_1MORE,</span><br><span class="line">  ngx_http_core_listen,</span><br><span class="line">  NGX_HTTP_SRV_CONF_OFFSET,</span><br><span class="line">  0,</span><br><span class="line">  NULL &#125;,</span><br></pre></td></tr></table></figure></p>
<p>它定义在server内，模块为ngx_http_core_module，在初始化这个模块的时候，会调用ngx_http_core_create_srv_conf 创建ngx_http_core_srv_conf_t<br>所以对于listen命令来讲，其conf就是ngx_http_core_srv_conf_t</p>
<p>总结一下，这样方式的好处就是在处理一个命令的时候，能方便的得到本模块在本实例的配置信息，也能得到本实例的其他模块的配置信息。</p>
<p>对于ngx_http_module，只有一个命令，即 http, 所以每次遇到一个http {}这样的配置段，就会执行ngx_http_block函数<br>那么ngx_http_block到底执行力啥东西呢？<br>对于每个http{}段，都会对应一个ngx_http_conf_ctx_t类型的ctx变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char *</span><br><span class="line">ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)</span><br></pre></td></tr></table></figure></p>
<p>创建的ctx变量会当成返回值赋值给参数conf，具体怎么用还不清楚。（这里推测conf和ngx_cycle里的<em>**</em>有关系）</p>
<p>对于每个http{}block来说，都会创建一个ngx_http_conf_ctx_t类型的变量，用于存储各个http模块的ctx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure></p>
<p>抽象的不要不要的，这也是我们要着重说的部分啦</p>
<h2 id="2-3-http-core的main"><a href="#2-3-http-core的main" class="headerlink" title="2.3 http_core的main"></a>2.3 http_core的main</h2><p>前面我们提到过，每个http模块的指令可以定义在不同的范围生效，这里先介绍最简单的情况：在main里生效的情况。这也是最简单的情况了。这个和前面提到的NGX_CORE_MODULE类型的模块类似，是以数组的方式组织的，下标即http模块的下标。<br>对于解析到一个http{}时候，会创建一个ctx，这个ctx就是下面的结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure>
<ul>
<li>main_conf,保留所有模块的main conf</li>
<li>srv_conf和loc_conf，看到这里的时候，敏感的人就会想，这里明明是main即全局的ctx，srv_conf和loc_conf会不会是没用的？答案是有用的，干啥用的，后面一起讲</li>
</ul>
<p>每个模块的main conf就保存在**main_conf里，比如access_log模块index是32，那么他的main conf就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((ngx_http_conf_ctx_t*)(cycle-&gt;conf_ctx[http_core_module_index]))-&gt;main_conf[32];</span><br></pre></td></tr></table></figure>
<h2 id="2-4-http-core的server"><a href="#2-4-http-core的server" class="headerlink" title="2.4 http_core的server"></a>2.4 http_core的server</h2><p>模块的指令定义在server段的话，是保存在哪里呢？server实例不是全局唯一的，而是可以定义多个的，所以先需要知道server实例保存在哪里，进而知道如何在server实例里保存这个模块的配置。<br>在2.3里提到过，每个HTTP模块通常有一个main_conf，注意有一个特殊的HTTP模块，那就是 ngx_http_core_module, 它有一个main conf，即ngx_http_core_main_conf_t。我们定义在一个<br>http{}的所有server实例ngx_http_core_srv_conf_t就保存在ngx_http_core_main_conf_t的servers成员里。</p>
<p>留意一下ngx_http_core_srv_conf_t本身里也有一个ngx_http_conf_ctx_t，那么这个家伙在这里又怎么理解呢？</p>
<ul>
<li>main_conf直接复用父实例的main_conf，因为这里已经是server段了</li>
<li>srv_conf保留了本实例里所有http模块的server conf配置，以模块下标索引，类似之前的思路</li>
<li>loc_conf，和前面一样，这里是server段的ctx，那么loc_conf是不是没啥用，同样是有用的。</li>
</ul>
<h2 id="2-5-http-core的location"><a href="#2-5-http-core的location" class="headerlink" title="2.5 http_core的location"></a>2.5 http_core的location</h2><p>和前面的思路一样，我们需要知道location实例的藏匿点。<br>server实例们保存在ngx_http_core_main_conf_t里，那么location们按理应该保存在ngx_http_core_srv_conf_t里。<br>但失望了，它们却保存在ngx_http_core_loc_conf_t里，主要是因为location是可以嵌套的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_queue_t  *locations;</span><br></pre></td></tr></table></figure>
<p>每个locations成员的类型是ngx_http_location_queue_t,具体怎么加入locations，请查阅代码ngx_http_add_location。<br>但ngx_http_location_queue_t只是一个封装，具体有逻辑的结构还是ngx_http_core_loc_conf_t。<br>ngx_http_core_loc_conf_t里有一个loc_conf的成员，答对了，他就是保存所有模块location配置的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* pointer to the modules&apos; loc_conf */</span><br><span class="line">void        **loc_conf;</span><br></pre></td></tr></table></figure></p>
<p>ngx_http_core_srv_conf_t里没有保存各个模块的srv_conf list只是保存了ctx，可以根据ctx间接找到所有模块的srv conf，为什么ngx_http_core_loc_conf_t里保存了loc_conf呢，<br>且没有ngx_http_conf_ctx_t类型的成员了呢？这个动机我还是不太清楚。<br>但这里有点需要指出的是，location是可以嵌套的。ngx_http_core_srv_conf_t的ctx的http_core模块，有个loc_conf[ngx_http_core_module.ctx_index]。<br>可以认为是这个server{}默认的location，其内的locations，记录了本server{}里的所有location。</p>
<h2 id="2-6-关于merge操作"><a href="#2-6-关于merge操作" class="headerlink" title="2.6 关于merge操作"></a>2.6 关于merge操作</h2><p>问题的起源是，如果一个选项比如access_log在main里和server各有配置，怎么办？模块的作者需要自己写merge函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static ngx_http_module_t  ngx_http_log_module_ctx = &#123;</span><br><span class="line">    NULL,                                  /* preconfiguration */</span><br><span class="line">    ngx_http_log_init,                     /* postconfiguration */</span><br><span class="line"></span><br><span class="line">    ngx_http_log_create_main_conf,         /* create main configuration */</span><br><span class="line">    NULL,                                  /* init main configuration */</span><br><span class="line"></span><br><span class="line">    NULL,                                  /* create server configuration */</span><br><span class="line">    NULL,                                  /* merge server configuration */</span><br><span class="line"></span><br><span class="line">    ngx_http_log_create_loc_conf,          /* create location configuration */</span><br><span class="line">    ngx_http_log_merge_loc_conf            /* merge location configuration */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么nginx是怎么回调用户自己的函数的呢？<br>而且回掉的时候的参数类型是一样的，比如一个模块的作者定义了一条指令 xxx on/off。这个指令可以在不同范围生效。<br>对应不同段的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_loc_conf_t</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_srv_conf_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_main_conf_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>假设模块的作者想要的规则是使用最小范围的。location没配，则用server里的，server里没配，则用main里的。<br>当merge location的时候，传入的都是ngx_http_xxx_loc_conf_t类型的。我当时的困惑是，location里的配置当然是ngx_http_xxx_loc_conf_t类型的，但server哪里来ngx_http_xxx_loc_conf_t类型的配置。</p>
<p>再联想一下前面说的问题，为啥创建server实例的时候，会把各个模块的location实例创建出来一个，那时候分明还有没有解析到location配置。这个家伙就是用来merge的。那问题来了，他的enable的值从哪里来呢？当然是在server段里配置 xxx on/off的时候。<br>其实前面的类型定义的代码是错误的，<br>当一个指令可以在各个范围生效的时候，需要把这个指令存储在最小的范围里，所以上面的定义应该改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_loc_conf_t</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    //</span><br><span class="line">&#125; ngx_http_xxx_srv_conf_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_flag_t                           enable;</span><br><span class="line">&#125; ngx_http_xxx_main_conf_t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后定义commands的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ngx_string(&quot;xxx&quot;),</span><br><span class="line">    NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONFNGX_CONF_FLAG,</span><br><span class="line">    ngx_conf_set_flag_slot,</span><br><span class="line">    NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">    offsetof(ngx_http_xxx_loc_conf_t, enable),</span><br><span class="line">    NULL</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>NGX_HTTP_LOC_CONF_OFFSET是告诉nginx，放到ctx的那个conf里，还记得ctx的定义么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    void        **main_conf;</span><br><span class="line">    void        **srv_conf;</span><br><span class="line">    void        **loc_conf;</span><br><span class="line">&#125; ngx_http_conf_ctx_t;</span><br></pre></td></tr></table></figure></p>
<p>然后offset那一行，告诉存储在那个变量里</p>
<p>最后关键来了，怎么merge呢？<br>答：对于一个模块来说，就是用main实例里的srv_conf和server实例里的srv_conf merge，然后用server实例里的loc_conf和location实例里的loc_conf merge。<br>注意merge的时候是会改变配置的哦。</p>
<h2 id="2-7-对于一个request，如何找对应的模块的配置"><a href="#2-7-对于一个request，如何找对应的模块的配置" class="headerlink" title="2.7 对于一个request，如何找对应的模块的配置"></a>2.7 对于一个request，如何找对应的模块的配置</h2><p>最后看一下运行态，对于一个请求来讲需要找到对应的srv和loc配置，才能处理起来<br>即ngx_http_get_module_ctx是如何生效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define ngx_http_get_module_main_conf(r, module)                             \</span><br><span class="line">    (r)-&gt;main_conf[module.ctx_index]</span><br><span class="line">#define ngx_http_get_module_srv_conf(r, module)  (r)-&gt;srv_conf[module.ctx_index]</span><br><span class="line">#define ngx_http_get_module_loc_conf(r, module)  (r)-&gt;loc_conf[module.ctx_index]</span><br></pre></td></tr></table></figure>
<p>所以就是看看我们的r是如何赋值 main_conf/svc_conf/loc_conf的</p>
<p>我原来以为看如何找main_conf是最容易的，但感觉有点复杂。<br>ngx_http_init_connection函数里，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* the default server configuration for the address:port */</span><br><span class="line">hc-&gt;conf_ctx = hc-&gt;addr_conf-&gt;default_server-&gt;ctx;</span><br></pre></td></tr></table></figure></p>
<p>但default_server-&gt;ctx尚不知如何赋值的。不过不管哪个server他们的main_conf都是一样的，知识srv_conf不一样而已。</p>
<p>然后再ngx_http_create_request里，就用了上面找到的ctx去找main_conf。<br>其他的两个容易看到 ngx_http_find_virtual_server，帮我们找到ngx_http_core_srv_conf_t配置。<br>ngx_http_core_find_location帮助我们找到对应的location，即为r-&gt;loc_conf赋值，有了这个之后，就可以找到这个location下的所有其他模块的配置</p>
<p>好了，分析结束，上一个大图。</p>
<p><img src="nginx_conf.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/10/nginx的配置管理/" data-id="cjuruem2g000s2glo35y5fz1n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-openssl签发证书" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/05/openssl签发证书/" class="article-date">
  <time datetime="2017-05-05T09:05:30.000Z" itemprop="datePublished">2017-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/05/openssl签发证书/">openssl签发证书</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h1><p>为了搭建https的测试环境，还是别用自己的正式证书了，想自己当把CA，颁发一些证书，自己当根。网上看了一些文章，都是当前目录建立一个demoCA这样的东西，但使用openssl ca 命令的时候，总是各种访问默认目录/etc/pki什么的，所以hi是放弃幻想了。直接用系统的目录做事情吧。</p>
<p>先看一下这个目录的结构吧</p>
<pre>
    [root@cq01-bce-48-29-31.cq01.baidu.com httpsec]# tree /etc/pki/CA
        /etc/pki/CA
        |-- certs
        |-- crl
        |-- newcerts
        `-- private
    4 directories, 0 files
</pre>


<h1 id="2-步骤"><a href="#2-步骤" class="headerlink" title="2.步骤"></a>2.步骤</h1><h2 id="2-1-生成私钥"><a href="#2-1-生成私钥" class="headerlink" title="2.1.生成私钥"></a>2.1.生成私钥</h2><p>进入CA目录，生成我们的一个私钥：</p>
<pre>
    cd /etc/pki/CA
    openssl genrsa -out private/cakey.pem 2048
</pre>

<p>大家可能问，公钥跑哪里去了，实际上生成的私钥里既有私钥，也有一些基础信息，用于将来生成公钥</p>
<pre>
    RSAPrivateKey ::= SEQUENCE {
        version Version,
        modulus INTEGER, -- n
        publicExponent INTEGER, -- e
        privateExponent INTEGER, -- d
        prime1 INTEGER, -- p
        prime2 INTEGER, -- q
        exponent1 INTEGER, -- d mod (p-1)
        exponent2 INTEGER, -- d mod (q-1)
        coefficient INTEGER, -- (inverse of q) mod p
        otherPrimeInfos OtherPrimeInfos OPTIONAL
    }

    RSAPublicKey ::= SEQUENCE {
        modulus INTEGER, -- n
        publicExponent INTEGER -- e
    }
</pre>


<h2 id="2-2-生成根证书"><a href="#2-2-生成根证书" class="headerlink" title="2.2.生成根证书"></a>2.2.生成根证书</h2><p>生成根证书有两种方式，一种是直接生成字签名根证书，一种是先生成根证书的请求文件csr，然后自己跟自己颁根证书</p>
<p>方法一</p>
<pre>
    openssl req -new -days 3650 -x509 -key ./private/cakey.pem -out  cacert.pem
</pre>


<p>方法二</p>
<pre>
    openssl req -new -key ./private/cakey.pem -out  rootca.csr
    openssl req -x509 -days 3650 -key ./private/cakey.pem -in rootca.csr -out cacert.pem
</pre>

<p>我们可以看下证书的内容</p>
<pre>
     openssl x509 -in rootca.crt -noout -text
</pre>



<h2 id="2-4-给别人签发证书"><a href="#2-4-给别人签发证书" class="headerlink" title="2.4.给别人签发证书"></a>2.4.给别人签发证书</h2><p>自己当了CA后，就可以给别人签发证书了。客户自己生成一个证书请求，给CA，CA就可以生成证书了</p>
<p>在客户机执行如下操作</p>
<pre>
    1.生成私钥
    openssl genrsa -out client1_key.pem 2048
    openssl  req -new -key  client1_key.pem  -out client1.csr
</pre>

<p>最后就是关键的 一步，签发证书,表示CA对证书申请者的认同。</p>
<pre>
    openssl ca -in client1.csr -out client1.pem
</pre>

<p>中间可能会提示index.txt文件和serial文件，按他的要求有这个两个文件即可，也可以一开始的时候就初始化好</p>
<pre>
    touch /etc/pki/CA/index.txt
    echo xyz > /etc/pki/CA/serial
</pre>

<p>好了，搞定！</p>
<p>期间需要注意的是，root CA的证书申请时候的Country,State,Comm那几个字段要一致，否则签发不了证书。可以自己试试。</p>
<p>补一个，证书导出公钥</p>
<pre>
openssl x509 -inform PEM -in client1.pem -outform PEM -pubkey -noout
</pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/05/openssl签发证书/" data-id="cjuruem2g000r2gloqsrpoaqr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-socket编程的内核实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/04/socket编程的内核实现/" class="article-date">
  <time datetime="2017-05-04T02:53:49.000Z" itemprop="datePublished">2017-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/04/socket编程的内核实现/">socket编程的内核实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-一些全局结构"><a href="#1-一些全局结构" class="headerlink" title="1.一些全局结构"></a>1.一些全局结构</h1><p>inetsw_array是全局定义的回调函数，不同协议，不同回调，可以简单看一下tcp协议的ops</p>
<pre>

    struct proto tcp_prot = {
    .name            = "TCP",
    .owner            = THIS_MODULE,
    .close            = tcp_close,
    .connect        = tcp_v4_connect,
    .disconnect        = tcp_disconnect,
    .accept            = inet_csk_accept,
    .ioctl            = tcp_ioctl,
    .init            = tcp_v4_init_sock,
    .destroy        = tcp_v4_destroy_sock,
    .shutdown        = tcp_shutdown,
</pre>


<p>tcp socket的ops</p>
<pre>
    const struct proto_ops inet_stream_ops = {
        .family           = PF_INET,
        .owner           = THIS_MODULE,
        .release       = inet_release,
        .bind           = inet_bind,
        .connect       = inet_stream_connect,
        .socketpair       = sock_no_socketpair,
        .accept           = inet_accept,
        .getname       = inet_getname,
        .poll           = tcp_poll,
        .ioctl           = inet_ioctl,
        .listen           = inet_listen,
        .shutdown       = inet_shutdown,
        .setsockopt       = sock_common_setsockopt,
        .getsockopt       = sock_common_getsockopt,
        .sendmsg       = inet_sendmsg,
        .recvmsg       = inet_recvmsg,
        .mmap           = sock_no_mmap,
        .sendpage       = inet_sendpage,
        .splice_read       = tcp_splice_read,
    #ifdef CONFIG_COMPAT
        .compat_setsockopt = compat_sock_common_setsockopt,
        .compat_getsockopt = compat_sock_common_getsockopt,
        .compat_ioctl       = inet_compat_ioctl,
    #endif
    };
</pre>

<p>真正开始listener在inet_csk_listen_start</p>
<p>tcp_rcv_state_process<br>    tcp_v4_conn_request</p>
<pre><code>inet_csk_reqsk_queue_hash_add
    inet_csk_reqsk_queue_added
        reqsk_queue_added
</code></pre><p>tcp_sock有seq ack之类的信息</p>
<p>sock<br>inet_sock</p>
<p>accept的入口<br>inet_csk_accept<br>它是从这个队列里取 struct request_sock_queue *queue = &amp;icsk-&gt;icsk_accept_queue;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/04/socket编程的内核实现/" data-id="cjuruem2h000t2glo1g5uhefj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-nginx与reuseport" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/04/nginx与reuseport/" class="article-date">
  <time datetime="2017-05-04T02:48:31.000Z" itemprop="datePublished">2017-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/04/nginx与reuseport/">关于reuseport那些事儿</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>nginx开启reuse port后，据说benchmark能跑很多。那么为啥nginx能在reuseport开启的情况下性能提升不少呢？nginx使用reuseport需要注意哪些问题呢？</p>
<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><p>reuseport是在nginx 1.9.1里提供了支持，官方更是提供了篇幅介绍reuseport带来的好处，主要是benchmark的提升。</p>
<p>具体详情可见：<a href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/" target="_blank" rel="noopener">https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/</a></p>
<p>我们这里想介绍一下，在nginx里是如何使用reuseport功能带来性能提升的</p>
<h2 id="2-reuseport的原理"><a href="#2-reuseport的原理" class="headerlink" title="2.reuseport的原理"></a>2.reuseport的原理</h2><p>在3.9内核以前，为了支持多进程模型像haproxy，nginx等，大家不约而同的采用的fork的做法，即在父进程里，监听一个IP+port。<br>然后fork出N个子进程，子进程天然继承了父进程的listen socket的句柄，即可以执行accept操作了。</p>
<p><img src="fork_share.png" alt=""></p>
<p>但因为是fork出来的，所以在kernel里，仍然是一个句柄，多个进程执行accept还是有竞争关系，所以nginx需要配置accept_mutex这样的开关</p>
<p>当开启reuseport后，每个监听地址将会有多个句柄，具体来说是一个worker一个，这样每个worker关心的listen socket就独立开了，自己搞定自己的事，避免了多进程的竞争。</p>
<p><img src="reuseport_share.png" alt=""></p>
<h2 id="3-reuseport在nginx的使用"><a href="#3-reuseport在nginx的使用" class="headerlink" title="3.reuseport在nginx的使用"></a>3.reuseport在nginx的使用</h2><p>通常情况下，使用reuseaddr都是启动多个进程，大家绑定相同的IP和port，然后就可以无限发挥reuseport的特性了。<br>但nginx毕竟还是采用了fork的模型。那么个是如何充分利用reuseport的呢？看代码吧。<br>在ngx_clone_listening里有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (n = 1; n &lt; ccf-&gt;worker_processes; n++) &#123;    </span><br><span class="line"></span><br><span class="line">    /* create a socket for each worker process */</span><br><span class="line"></span><br><span class="line">    ls = ngx_array_push(&amp;cf-&gt;cycle-&gt;listening);</span><br><span class="line">    if (ls == NULL) &#123;</span><br><span class="line">        return NGX_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ls = ols;</span><br><span class="line">    ls-&gt;worker = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(注意是从1开始的，因为master会创建一个worker是0的listener)<br>也就是解析完配置文件后，会根据worker的个数fork出来多个listener对象，统一扔到数组里，那么啥时候打开监听呢?</p>
<p>ngx_init_cycle<br>—&gt;ngx_open_listening_sockets<br>    —&gt;bind<br>    —&gt;listen</p>
<p>因为设置了reuseport，所以数组里塞进去的ip port重复的listener可以创建好。<br>比如有8个worker，会创建出8个listen socket。</p>
<p>那么剩下来的问题就是，如何让一个listen socket和worker进程绑定。</p>
<p>那么就看ngx_event_process_init，worker进程初始化event模块的时候，会调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (NGX_HAVE_REUSEPORT)</span><br><span class="line">       if (ls[i].reuseport &amp;&amp; ls[i].worker != ngx_worker) &#123;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里可以看出，我只把自己worker对应的listen socket加入到epoll里去。</p>
<h2 id="4-reuseport在nginx使用中遇到的问题"><a href="#4-reuseport在nginx使用中遇到的问题" class="headerlink" title="4.reuseport在nginx使用中遇到的问题"></a>4.reuseport在nginx使用中遇到的问题</h2><p>先说现象：<br>nginx从reuseport升级为非reuseport，以及从多worker升级为少worker都会有大量性能下降。<br>这里还是需要介绍一下reuseport的升级的流程，好trick。</p>
<p>升级的时候，也就是-USR2的时候，old maste启动新master的时候，会把所有listen socket的句柄们放在新进程的环境变量里。如果reuseport，举监听80端口为例，如果开启了4个worker，那么环境变量则存了4个句柄，格式为<br>句柄id1；句柄id2；句柄id3；句柄id4。<br>新的master启动后会把这个4个句柄读出来，注意，这4个句柄在新进程里也是合法的，然后调用各种syscall获得这个句柄的信息</p>
<ul>
<li>ls[i].sockaddr (调用getsockname())</li>
<li>ls[i].addr_text_max_len</li>
<li>ls[i].addr_text</li>
<li>ls[i].backlog</li>
<li>ls[i].rcvbuf (调用getsockopt())</li>
<li>ls[i].sndbuf (调用getsockopt())</li>
<li>ls[i].accept_filter</li>
<li>ls[i].deferred_accept</li>
</ul>
<p>这个信息是放在old_cycle里的，然后加载配置文件，配置文件里也依然会监听80端口，这时新的cycle的listening数组里会有一个ngx_listening_t,但是在ngx_http_optimize_servers里会间接调用ngx_clone_listening，来clone出 worker个数的listen句柄，但这时候因为还没有调用listen函数，所以ls[i]的fd是空，肯定不会走后面的listen函数的，因为环境变量已经把老的句柄传递过来了，直接复用即可，而且如果不复用，重新listen的话会出问题的，因为老的句柄在内核有queue，确没人accept。<br>那么是哪里为新的ngx_listening_t赋值的呢？就是在init_cycle的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (n = 0; n &lt; cycle-&gt;listening.nelts; n++) &#123;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; old_cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line">        if (ls[i].ignore) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ls[i].remain) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ls[i].type != nls[n].type) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ngx_cmp_sockaddr(nls[n].sockaddr, nls[n].socklen,</span><br><span class="line">                             ls[i].sockaddr, ls[i].socklen, 1)</span><br><span class="line">            == NGX_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            nls[n].fd = ls[i].fd;</span><br><span class="line">            nls[n].previous = &amp;ls[i];</span><br><span class="line">            ls[i].remain = 1;</span><br><span class="line"></span><br><span class="line">            if (ls[i].backlog != nls[n].backlog) &#123;</span><br><span class="line">                nls[n].listen = 1;</span><br><span class="line">            &#125;</span><br><span class="line">...................</span><br></pre></td></tr></table></figure><br>对比新的cycle和旧的cycle，如果监听的地址一样，就拿来复用，已经复用的remain会置为1，下一个相同地址的就不会复用了。比如老的cycle里因为reuseport，一个ip+80，开启了4个 listen句柄，新的也开启4个listen结构，在上面的二层循环里，就一次把这个4个句柄赋值给新的 ngx_listening_t的fd。</p>
<p>这里的remain名字起的真是烂啊，我觉得叫copied/inherited都可以。</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><p>reuseport功能会给nginx的性能带来很大的提升。但是升级的时候由于老的master的延迟退出，会导致在老的master退出之前，性能骤降，这和本来的on the fly upgrade 风格实在是落差不小。<br>也许是我理解有误，知道的小伙伴可以mail我。qzzhou$126.com</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/05/04/nginx与reuseport/" data-id="cjuruem2e000o2gloqqtyp0hf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/reuseport/">reuseport</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="ssl-RSA加密" class="article article-type-ssl" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/20/RSA加密/" class="article-date">
  <time datetime="2017-01-20T08:31:21.000Z" itemprop="datePublished">2017-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/20/RSA加密/">RSA加密</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;openssl/rsa.h&gt;</span><br><span class="line">#include&lt;openssl/pem.h&gt;</span><br><span class="line">#include&lt;openssl/err.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int base64_encode(char *in_str, int in_len, char *out_str)</span><br><span class="line">&#123;</span><br><span class="line">    BIO *b64, *bio;</span><br><span class="line">    BUF_MEM *bptr = NULL;</span><br><span class="line">    size_t size = 0;</span><br><span class="line"></span><br><span class="line">    if (in_str == NULL || out_str == NULL)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    b64 = BIO_new(BIO_f_base64());</span><br><span class="line">    bio = BIO_new(BIO_s_mem());</span><br><span class="line">    bio = BIO_push(b64, bio);</span><br><span class="line"></span><br><span class="line">    BIO_write(bio, in_str, in_len);</span><br><span class="line">    BIO_flush(bio);</span><br><span class="line"></span><br><span class="line">    BIO_get_mem_ptr(bio, &amp;bptr);</span><br><span class="line">    memcpy(out_str, bptr-&gt;data, bptr-&gt;length);</span><br><span class="line">    out_str[bptr-&gt;length] = &apos;\0&apos;;</span><br><span class="line">    size = bptr-&gt;length;</span><br><span class="line"></span><br><span class="line">    BIO_free_all(bio);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int base64_decode(char *in_str, int in_len, char *out_str)</span><br><span class="line">&#123;</span><br><span class="line">    BIO *b64, *bio;</span><br><span class="line">    BUF_MEM *bptr = NULL;</span><br><span class="line">    int counts;</span><br><span class="line">    int size = 0;</span><br><span class="line"></span><br><span class="line">    if (in_str == NULL || out_str == NULL)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    b64 = BIO_new(BIO_f_base64());</span><br><span class="line">    //BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);</span><br><span class="line"></span><br><span class="line">    bio = BIO_new_mem_buf(in_str, in_len);</span><br><span class="line">    bio = BIO_push(b64, bio);</span><br><span class="line"></span><br><span class="line">    size = BIO_read(bio, out_str, in_len);</span><br><span class="line">    out_str[size] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    BIO_free_all(bio);</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    char data[3048];</span><br><span class="line">    char out[2048];</span><br><span class="line">    char data_base64_pre[3048];</span><br><span class="line">    char data_base64[3048];</span><br><span class="line">    char data_unbase64[3048];</span><br><span class="line"></span><br><span class="line">    char *pub_key_path = argv[1];</span><br><span class="line">    char *priv_key_path = argv[2];</span><br><span class="line">    char *data_path = argv[3];</span><br><span class="line">    RSA *pub_rsa;</span><br><span class="line">    RSA *priv_rsa;</span><br><span class="line">    FILE *file;</span><br><span class="line">    int flen,rsa_len;</span><br><span class="line">    int enc_len = 0;</span><br><span class="line">    int dec_len = 0;</span><br><span class="line">    int data_len = 0;</span><br><span class="line">    int data_unbase64_len = 0;</span><br><span class="line">    int data_base64_len = 0;</span><br><span class="line">    int data_base64_pre_len = 0;</span><br><span class="line"></span><br><span class="line">    char* enc_buf;</span><br><span class="line">    char* dec_buf;</span><br><span class="line"></span><br><span class="line">    BIO* bio_data;</span><br><span class="line"></span><br><span class="line">    BIO* bio;</span><br><span class="line">    BIO* bio_enc;</span><br><span class="line"></span><br><span class="line">    BIO* bio_64;</span><br><span class="line">    BUF_MEM *bptr;</span><br><span class="line"></span><br><span class="line">    if (argc != 4) &#123;</span><br><span class="line">        printf(&quot;\n usage:\n&quot;);</span><br><span class="line">        printf(&quot;\t %s pub_key_file priv_key_file data_file\n&quot;, argv[0]);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if((file=fopen(pub_key_path,&quot;r&quot;))==NULL)&#123;</span><br><span class="line">        perror(&quot;open public key file error&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if((pub_rsa=PEM_read_RSA_PUBKEY(file,NULL,NULL,NULL))==NULL)&#123;</span><br><span class="line">        ERR_print_errors_fp(stdout);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    if((file=fopen(priv_key_path,&quot;r&quot;))==NULL)&#123;</span><br><span class="line">        perror(&quot;open private key file error&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    if((priv_rsa=PEM_read_RSAPrivateKey(file,NULL,NULL,NULL))==NULL)&#123;</span><br><span class="line">        ERR_print_errors_fp(stdout);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    bzero(data, sizeof(data));</span><br><span class="line">    if((file=fopen(data_path,&quot;r&quot;))==NULL)&#123;</span><br><span class="line">        perror(&quot;open private key file error&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    data_len = fread(data, 1, sizeof(data), file);</span><br><span class="line">    printf(&quot;read data length:%d\n&quot;, data_len);</span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">        bio = BIO_new(BIO_s_mem());</span><br><span class="line">        BIO_write(bio, data, data_len);</span><br><span class="line"></span><br><span class="line">        bio_enc = BIO_new(BIO_s_mem());</span><br><span class="line"></span><br><span class="line">        rsa_len = RSA_size(pub_rsa);</span><br><span class="line">        //printf(&quot;pub rsa size:%d\n&quot;, rsa_len);</span><br><span class="line">        enc_buf = malloc(rsa_len);</span><br><span class="line">        while(1) &#123;</span><br><span class="line">            char data[100];</span><br><span class="line">            int data_len = BIO_read(bio, data, sizeof(data));</span><br><span class="line">            // printf(&quot;read bytes:%d\n&quot;, data_len);</span><br><span class="line">            if (data_len &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            bzero(enc_buf, rsa_len);</span><br><span class="line">            enc_len = RSA_public_encrypt(data_len, data, enc_buf, pub_rsa, RSA_PKCS1_PADDING);</span><br><span class="line">            //printf(&quot;encoded length:%d\n&quot;, enc_len);</span><br><span class="line">            BIO_write(bio_enc, enc_buf, enc_len);</span><br><span class="line">        &#125;</span><br><span class="line">        BIO_free(bio);</span><br><span class="line">        BIO_flush(bio_enc);</span><br><span class="line"></span><br><span class="line">        // all the data has been encript</span><br><span class="line">        BIO_get_mem_ptr(bio_enc, &amp;bptr);</span><br><span class="line">        memcpy(data_base64_pre, bptr-&gt;data, bptr-&gt;length);</span><br><span class="line">        data_base64_pre_len = bptr-&gt;length;</span><br><span class="line"></span><br><span class="line">        BIO_free(bio_enc);</span><br><span class="line"></span><br><span class="line">        //printf(&quot;length after encoded:%d\n&quot;, data_len);</span><br><span class="line">        //now base64 encode</span><br><span class="line">        data_base64_len = base64_encode(data_base64_pre, data_base64_pre_len, data_base64);</span><br><span class="line">        //printf(&quot;data length after base64 encode:%d\n&quot;, data_base64_len);</span><br><span class="line">        // printf(&quot;data content after base64 encode:\n%s\n&quot;, data_base64);</span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0;i&lt;1000;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // now decript</span><br><span class="line">        data_unbase64_len = base64_decode(data_base64, data_base64_len, data_unbase64);</span><br><span class="line">        //printf(&quot;data length after base64 decode:%d\n&quot;, data_base64_len);</span><br><span class="line">        //printf(&quot;data content after base64 decode:%s\n&quot;, data_unbase64);</span><br><span class="line"></span><br><span class="line">        //printf(&quot;base64 decode length:%d\n&quot;, data_unbase64_len);</span><br><span class="line">        bio_64 = BIO_new(BIO_s_mem());</span><br><span class="line">        BIO_write(bio_64, data_unbase64, data_base64_len);</span><br><span class="line"></span><br><span class="line">        dec_buf = malloc(rsa_len);</span><br><span class="line">        while(1) &#123;</span><br><span class="line">            dec_len = BIO_read(bio_64, dec_buf, rsa_len);</span><br><span class="line">            if(dec_len &lt;= 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            bzero(out, sizeof(out));</span><br><span class="line">            dec_len = RSA_private_decrypt(dec_len, dec_buf, out, priv_rsa, RSA_PKCS1_PADDING);</span><br><span class="line">            //printf(&quot;%s&quot;, out);</span><br><span class="line">        &#125;</span><br><span class="line">        BIO_free(bio_64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2017/01/20/RSA加密/" data-id="cjuruem1w00042glo7sf20ivt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RSA加密/">RSA加密</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openssl/">openssl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-nginx进程架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/09/nginx进程架构/" class="article-date">
  <time datetime="2016-10-09T02:53:33.000Z" itemprop="datePublished">2016-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/09/nginx进程架构/">nginx进程架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>nginx默认采用的是多进程的架构方式。和haproxy有很大的不同，haproxy作者是推荐使用但进程的方式的，因为作者认为单进程的性能能应付大部分的case。而且多进程会带来很复杂的管理面问题，所以也不得宠。<br>但nginx采用单master+多worker进程的架构方式，天然就是为了多进程服务。<br>很多人看nginx代码，都迫不及待的看什么样的io模型，怎么快速做的http解析和收发等数据平面的东西，但当面临使用的时候，管理面遇到的问题远远比数据面严重的多，比如我们要是在云环境中使用nginx为用户做负载均衡或者cdn/waf之类的，必然要考虑如下的问题</p>
<ul>
<li>如何做到横向扩展，比如一台机器启动多少进程？多加机器能解决性能问题么？</li>
<li>m台机器，一台机器n个nginx进程，如何管理这些m*n个进程？比如加载新配置，比如重启死循环或者hang住的进程</li>
<li>当升级重启的时候，如何做到真正的0宕机？</li>
<li>m*n的nginx集群，他们的统计怎么搞？比如访问的top 10 域名是什么？</li>
</ul>
<p>master进程可以认为是管理平面的东西：</p>
<ul>
<li>加载/更新配置文件</li>
<li>管理所有worker进程的创建，重启</li>
</ul>
<p>然后我们看一下nginx是如何管理worker进程和配置文件的更新的</p>
<h1 id="2-关于worker进程的管理"><a href="#2-关于worker进程的管理" class="headerlink" title="2.关于worker进程的管理"></a>2.关于worker进程的管理</h1><p>worker进程是从master进程fork出来的进程，nginx提供了几种不同的fork方式：</p>
<ul>
<li>NGX_PROCESS_NORESPAWN</li>
<li>NGX_PROCESS_JUST_SPAWN</li>
<li>NGX_PROCESS_RESPAWN</li>
<li>NGX_PROCESS_JUST_RESPAWN</li>
<li>NGX_PROCESS_DETACHED</li>
</ul>
<p>我们一个一个理一下</p>
<h2 id="2-1-NGX-PROCESS-RESPAWN"><a href="#2-1-NGX-PROCESS-RESPAWN" class="headerlink" title="2.1.NGX_PROCESS_RESPAWN"></a>2.1.NGX_PROCESS_RESPAWN</h2><p>这个是最常规的操作，fork worker进程的时候设置这个标志，当worker进程因为意外退出的时候，master进程会执行再生(respawn)操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static ngx_uint_t</span><br><span class="line">ngx_reap_children(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line">    //......</span><br><span class="line">    if (ngx_processes[i].exited) &#123;</span><br><span class="line">        //......</span><br><span class="line">        if (ngx_processes[i].respawn</span><br><span class="line">                &amp;&amp; !ngx_processes[i].exiting</span><br><span class="line">                &amp;&amp; !ngx_terminate</span><br><span class="line">                &amp;&amp; !ngx_quit)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ngx_spawn_process(cycle, ngx_processes[i].proc,</span><br><span class="line">            //.....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以可以认为初次启动master的时候（比如刚启动，比如更新二进制了）都用以这个参数启动worker</p>
<h2 id="2-2-NGX-PROCESS-JUST-RESPAWN"><a href="#2-2-NGX-PROCESS-JUST-RESPAWN" class="headerlink" title="2.2.NGX_PROCESS_JUST_RESPAWN"></a>2.2.NGX_PROCESS_JUST_RESPAWN</h2><p>just是刚刚的意思，刚刚spawn出来的，用于更新配置的时候，因为更新配置执行如下的步骤<br>1.master加载新配置文件<br>2.fork新的worker进程<br>3.给使用旧配置文件的worker进程发QUIT信号</p>
<p>第二步fork进程的时候腰加上NGX_PROCESS_JUST_RESPAWN这个标志，用于给第三步区分哪些是旧进程，哪些是新欢。</p>
<h2 id="2-3-NGX-PROCESS-JUST-SPAWN"><a href="#2-3-NGX-PROCESS-JUST-SPAWN" class="headerlink" title="2.3.NGX_PROCESS_JUST_SPAWN"></a>2.3.NGX_PROCESS_JUST_SPAWN</h2><p>这个和上一个差不多，用于cache manager，我不喜欢</p>
<p>这里注意一下，上面提到的3个类型，其实是转化成2个标志的，即respawn和just。<br>just:刚刚搞出来的，别动我，只动就的，用于区分新旧<br>respawn:本进程被master管理，死的时候可以自动拉起<br>spwawn由于前面没有re，只是fork出来就拉倒，所以JUST_SPAWN只有just是有含义的</p>
<h2 id="2-4-NGX-PROCESS-DETACHED"><a href="#2-4-NGX-PROCESS-DETACHED" class="headerlink" title="2.4.NGX_PROCESS_DETACHED"></a>2.4.NGX_PROCESS_DETACHED</h2><p>这是说fork出来的进程和父进程没有管理的关系，比如nginx的master升级（老版本有bug），新的master从旧的mastr fork出来，就需要这样的标志，fork出来后和父进程没啥关系</p>
<h2 id="2-5-NGX-PROCESS-NORESPAWN"><a href="#2-5-NGX-PROCESS-NORESPAWN" class="headerlink" title="2.5.NGX_PROCESS_NORESPAWN"></a>2.5.NGX_PROCESS_NORESPAWN</h2><p>cache loader会用到，当第一次启动的时候，使用NGX_PROCESS_NORESPAWN，就是启动一个进程执行ngx_cache_manager_process_cycle.但需要注意和上面的DETACHED的区别，因为在nginx里，一般父子进程都有很多管道通讯，只有DETACHED的模式下没有pipe通讯，这个NORESPAWN是保留了和父进程的管道通讯的</p>
<p>但是当重新加载配置的时候，还是继续使用NGX_PROCESS_JUST_SPAWN来区分新欢旧爱的</p>
<h1 id="3-关于配置文件的加载过程"><a href="#3-关于配置文件的加载过程" class="headerlink" title="3.关于配置文件的加载过程"></a>3.关于配置文件的加载过程</h1><p>修改完配置文件后，通过如下的步骤让配置文件生效</p>
<ul>
<li>给master进程发送HUP信号</li>
</ul>
<p>master收到信号后会设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx_reconfigure = 1;</span><br></pre></td></tr></table></figure>
<p>然后下个周期检查ngx_reconfigure，调用ngx_init_cycle重新解析配置文件，生成一个cycle，注意一个cycle可以理解对应一个配置文件的周期。<br>在ngx_init_cycle里会做一些listner的bind和unbind操作，即旧的listener和新的listener的merge，当然还有其他配置的merge。</p>
<ul>
<li>fork worker进程</li>
</ul>
<p>worker进程里当然会能访问前面的cycle对象</p>
<ul>
<li>给所有旧的worker发送NGX_SHUTDOWN_SIGNAL信号</li>
</ul>
<p>旧的worker进程收到后，会关闭listen socket，然后等所有连接断开后，进程退出。</p>
<h1 id="4-关于二进制的升级"><a href="#4-关于二进制的升级" class="headerlink" title="4.关于二进制的升级"></a>4.关于二进制的升级</h1><p>写代码难免有bug，有bug就得改，改了后想生效就得升级。</p>
<p>给master发送一个USR2信号，ngx_change_binary会设置为1.<br>然后在那个ngx_init_cycle里，master进程会fork进程执行新的二进制（ngx_execute_proc）<br>ngx_new_binary会赋值为新master的进程id。<br>master起来后就是全新的master，会自动拉起新的worker进程，注意老master和新master都监听相同的listen socket，因为是fork出来执行execv的所以一样，nginx的listen socket的merger是它的killer feature。</p>
<p>这时候2套master和worker进程都在了，然后给旧的master发送WINCH信号,master会给worker发送graceful shutdown通知<br>这样就剩下旧的master+新的master+新的worker了，<br>为啥要留着旧的master呢？因为怕新的二进制有问题，如果有问题的话，</p>
<ul>
<li>发送HUP给旧的master，旧的worker就起来了</li>
<li>发送TERM给新的master，刚来起来的worker就被干掉了</li>
</ul>
<!-- 多说评论框 start -->
<pre><code>&lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;nginx_1&quot; data-title=&quot;nginx进程架构&quot; data-url=&quot;&quot;&gt;&lt;/div&gt;
</code></pre><!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<p><script type="text/javascript"><br>var duoshuoQuery = {short_name:”abonege”};<br>    (function() {<br>        var ds = document.createElement(‘script’);<br>        ds.type = ‘text/javascript’;ds.async = true;<br>        ds.src = (document.location.protocol == ‘https:’ ? ‘https:’ : ‘http:’) + ‘//static.duoshuo.com/embed.js’;<br>        ds.charset = ‘UTF-8’;<br>        (document.getElementsByTagName(‘head’)[0]<br>         || document.getElementsByTagName(‘body’)[0]).appendChild(ds);<br>    })();<br>    </script><br><!-- 多说公共JS代码 end --></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2016/10/09/nginx进程架构/" data-id="cjuruem2t00102glosges4lor" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nginx/">nginx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于代码优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/21/关于代码优化/" class="article-date">
  <time datetime="2016-08-21T03:30:51.000Z" itemprop="datePublished">2016-08-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/21/关于代码优化/">关于代码优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们在做c coding的时候，如何才能才能更高效的呢？</p>
<h2 id="1-读写数据尽量分开"><a href="#1-读写数据尽量分开" class="headerlink" title="1.读写数据尽量分开"></a>1.读写数据尽量分开</h2><p>因为CPU在执行内存指令的时候，是以cache line为单位夹在的，比如32或64个字节。<br>如果读写交叉，很容易造成cache line频繁失效</p>
<h2 id="2-局部变量到底是好是坏，太大了是否可以？"><a href="#2-局部变量到底是好是坏，太大了是否可以？" class="headerlink" title="2.局部变量到底是好是坏，太大了是否可以？"></a>2.局部变量到底是好是坏，太大了是否可以？</h2><p>每次夹在函数栈上的东西都要入cache</p>
<h2 id="3-减少code-path，检查不必要的调用"><a href="#3-减少code-path，检查不必要的调用" class="headerlink" title="3.减少code path，检查不必要的调用"></a>3.减少code path，检查不必要的调用</h2><h2 id="4-频繁调用-相关联的函数聚集到一起，一次型夹在到cpu-cache"><a href="#4-频繁调用-相关联的函数聚集到一起，一次型夹在到cpu-cache" class="headerlink" title="4.频繁调用/相关联的函数聚集到一起，一次型夹在到cpu cache"></a>4.频繁调用/相关联的函数聚集到一起，一次型夹在到cpu cache</h2><h2 id="5-数据结构的cache-line对其"><a href="#5-数据结构的cache-line对其" class="headerlink" title="5.数据结构的cache line对其"></a>5.数据结构的cache line对其</h2><p>如果是64 bit的cache line，就让首地址%64 =0</p>
<h2 id="6-参数不能太多，否则参数寄存器就不够用了"><a href="#6-参数不能太多，否则参数寄存器就不够用了" class="headerlink" title="6.参数不能太多，否则参数寄存器就不够用了"></a>6.参数不能太多，否则参数寄存器就不够用了</h2><h2 id="7-延迟计算，需要的时候才计算"><a href="#7-延迟计算，需要的时候才计算" class="headerlink" title="7. 延迟计算，需要的时候才计算"></a>7. 延迟计算，需要的时候才计算</h2><h2 id="8-提前计算-复用结果"><a href="#8-提前计算-复用结果" class="headerlink" title="8.提前计算+复用结果"></a>8.提前计算+复用结果</h2><h2 id="9-per-CPU-变量"><a href="#9-per-CPU-变量" class="headerlink" title="9. per-CPU 变量"></a>9. per-CPU 变量</h2><h2 id="10-分支预测likely-unlikely"><a href="#10-分支预测likely-unlikely" class="headerlink" title="10.分支预测likely unlikely"></a>10.分支预测likely unlikely</h2><h2 id="11-进程切换会刷tlb，cr3寄存器"><a href="#11-进程切换会刷tlb，cr3寄存器" class="headerlink" title="11.进程切换会刷tlb，cr3寄存器"></a>11.进程切换会刷tlb，cr3寄存器</h2><h2 id="12-如何调试coredump"><a href="#12-如何调试coredump" class="headerlink" title="12.如何调试coredump"></a>12.如何调试coredump</h2><p>1.根据栈信息<br>2.根据挂的地址信息和nm出来的结果对比<br>3.copy越界<br>4.非法地址访问，不存在/只读用来写等</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2016/08/21/关于代码优化/" data-id="cjuruem2n000y2gloqv7sa1xv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-neutron资源添加属性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/30/neutron资源添加属性/" class="article-date">
  <time datetime="2016-06-30T07:14:15.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/neutron资源添加属性/">neutron资源添加属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>理论上来说neutron client和neutron server是分离的，server端添加属性，client端无影响，只是show或不show而已，但有时候添加了属性，client用-c参数也show不出来。这时候一般是server添加属性的时候拉下地方了。</p>
<p>举例firewall来阐述一下添加属性步骤如下：</p>
<ul>
<li>数据库增加一列attr_new</li>
</ul>
<p>这步比较简单，轻松搞定</p>
<ul>
<li>修改Firewall对象，增加一列，在firewall_db.py里</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Firewall(model_base.BASEV2, models_v2.HasId, models_v2.HasTenant):</span><br><span class="line">    &quot;&quot;&quot;Represents a Firewall resource.&quot;&quot;&quot;</span><br><span class="line">    __tablename__ = &apos;firewalls&apos;</span><br><span class="line">    name = sa.Column(sa.String(255))</span><br><span class="line">    description = sa.Column(sa.String(1024))</span><br><span class="line">    shared = sa.Column(sa.Boolean)</span><br><span class="line">    admin_state_up = sa.Column(sa.Boolean)</span><br><span class="line">    status = sa.Column(sa.String(16))</span><br><span class="line">    firewall_policy_id = sa.Column(sa.String(36),</span><br><span class="line">                                   sa.ForeignKey(&apos;firewall_policies.id&apos;),</span><br><span class="line">                                   nullable=True)</span><br><span class="line">    creator = sa.Column(sa.String(255))</span><br><span class="line">    attr_new = sa.Column(sa.String(255))   # new attribute</span><br></pre></td></tr></table></figure>
<ul>
<li>修改show的地方即，get_firewalls函数,其实主要是函数_make_firewall_dict</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def _make_firewall_dict(self, fw, fields=None):</span><br><span class="line">    res = &#123;&apos;id&apos;: fw[&apos;id&apos;],</span><br><span class="line">           &apos;tenant_id&apos;: fw[&apos;tenant_id&apos;],</span><br><span class="line">           &apos;name&apos;: fw[&apos;name&apos;],</span><br><span class="line">           &apos;description&apos;: fw[&apos;description&apos;],</span><br><span class="line">           &apos;shared&apos;: fw[&apos;shared&apos;],</span><br><span class="line">           &apos;admin_state_up&apos;: fw[&apos;admin_state_up&apos;],</span><br><span class="line">           &apos;status&apos;: fw[&apos;status&apos;],</span><br><span class="line">           &apos;firewall_policy_id&apos;: fw[&apos;firewall_policy_id&apos;],</span><br><span class="line">           &apos;creator&apos;: fw[&apos;creator&apos;]</span><br><span class="line">           &apos;attr_new&apos;: fw[&apos;attr_new&apos;]&#125;</span><br><span class="line">    return self._fields(res, fields)</span><br></pre></td></tr></table></figure>
<ul>
<li>别以为完事了，最重要的是修改plugin的RESOURCE_ATTRIBUTE_MAP，这个是每个plugin/service给api的接口，来介绍自己的属性列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&apos;firewalls&apos;: &#123;</span><br><span class="line">    &apos;id&apos;: &#123;&apos;allow_post&apos;: False, &apos;allow_put&apos;: False,</span><br><span class="line">           &apos;validate&apos;: &#123;&apos;type:uuid&apos;: None&#125;,</span><br><span class="line">           &apos;is_visible&apos;: True,</span><br><span class="line">           &apos;primary_key&apos;: True&#125;,</span><br><span class="line">    &apos;tenant_id&apos;: &#123;&apos;allow_post&apos;: True, &apos;allow_put&apos;: False,</span><br><span class="line">                  &apos;required_by_policy&apos;: True,</span><br><span class="line">                  &apos;is_visible&apos;: True&#125;,</span><br><span class="line">    &apos;name&apos;: &#123;&apos;allow_post&apos;: True, &apos;allow_put&apos;: True,</span><br><span class="line">             &apos;validate&apos;: &#123;&apos;type:string&apos;: None&#125;,</span><br><span class="line">    &apos;attr_new&apos;: &#123;&apos;allow_post&apos;: True, &apos;allow_put&apos;: True,</span><br><span class="line">             &apos;validate&apos;: &#123;&apos;type:string&apos;: None&#125;,</span><br></pre></td></tr></table></figure>
<p>好了，大功告成</p>
<p>如果想用neutron client自动show firewall的新属性 则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">25 class ListFirewall(neutronv20.ListCommand):</span><br><span class="line">26     &quot;&quot;&quot;List firewalls that belong to a given tenant.&quot;&quot;&quot;</span><br><span class="line">27</span><br><span class="line">28     resource = &apos;firewall&apos;</span><br><span class="line">29     list_columns = [&apos;id&apos;, &apos;name&apos;, &apos;firewall_policy_id&apos;, &apos;attr_new&apos;]</span><br><span class="line">30     _formatters = &#123;&#125;</span><br><span class="line">31     pagination_support = True</span><br><span class="line">32     sorting_support = True</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2016/06/30/neutron资源添加属性/" data-id="cjuruem2b000j2glo0mqoo7hh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-创建资源后如何通知agent" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/27/创建资源后如何通知agent/" class="article-date">
  <time datetime="2016-06-27T03:05:55.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/创建资源后如何通知agent/">创建资源后如何通知agent</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当一个subnet创建后，需要通知dhcp-agent等,比如subnet_delete，subnet_create等，这个notify是什么时候发的呢，原来在API的Controller里<br><figure class="highlight plain"><figcaption><span>[python]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def delete(self, request, id, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Deletes the specified entity.&quot;&quot;&quot;</span><br><span class="line">    notifier_api.notify(request.context,</span><br><span class="line">                        self._publisher_id,</span><br><span class="line">                        self._resource + &apos;.delete.start&apos;,</span><br><span class="line">                        notifier_api.CONF.default_notification_level,</span><br><span class="line">                        &#123;self._resource + &apos;_id&apos;: id&#125;)</span><br><span class="line">    action = self._plugin_handlers[self.DELETE]</span><br><span class="line"></span><br><span class="line">    # Check authz</span><br><span class="line">    parent_id = kwargs.get(self._parent_id_name)</span><br><span class="line">    obj = self._item(request, id, parent_id=parent_id)</span><br><span class="line">    try:</span><br><span class="line">        policy.enforce(request.context,</span><br><span class="line">                       action,</span><br><span class="line">                       obj,</span><br><span class="line">                       resource=id)</span><br><span class="line">    except exceptions.PolicyNotAuthorized as err:</span><br><span class="line">        # To avoid giving away information, pretend that it</span><br><span class="line">        # doesn&apos;t exist</span><br><span class="line">        raise webob.exc.HTTPForbidden(explanation=err.msg)</span><br><span class="line"></span><br><span class="line">    obj_deleter = getattr(self._plugin, action)</span><br><span class="line">    obj_deleter(request.context, id, **kwargs)</span><br><span class="line">    notifier_method = self._resource + &apos;.delete.end&apos;</span><br><span class="line">    notifier_api.notify(request.context,</span><br><span class="line">                        self._publisher_id,</span><br><span class="line">                        notifier_method,</span><br><span class="line">                        notifier_api.CONF.default_notification_level,</span><br><span class="line">                        &#123;self._resource + &apos;_id&apos;: id&#125;)</span><br><span class="line">    result = &#123;self._resource: self._view(request.context, obj)&#125;</span><br><span class="line">    self._nova_notifier.send_network_change(action, &#123;&#125;, result)</span><br><span class="line">    self._send_dhcp_notification(request.context,</span><br><span class="line">                                 result,</span><br><span class="line">                                 notifier_method)  &lt;----------</span><br></pre></td></tr></table></figure></p>
<p>代码里经常看到<br>create_XXX_precommit<br>create_XXX_postcommit<br>这样的函数，我以为是通知agent的呢，但看了子网的这2个家伙，发现只是通知driver而已，通知agent是由上面的notifyer完成的，可以看下面的log</p>
<p>&lt;% codeblock %&gt;<br>2016-06-27 12:00:55.725 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######3:&lt;stevedore.extension.Extension object at 0x4b85c90&gt;<br>2016-06-27 12:00:55.736 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######4:<class 'stevedore.extension.extension'=""><br>2016-06-27 12:00:55.736 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######5:(&lt;bound method BareMetalMechanismDriver.delete_subnet_postc<br>ommit of &lt;neutron.plugins.ml2.drivers.mech_baremetal.BareMetalMechanismDriver object at 0x3a42610&gt;&gt;,)<br>2016-06-27 12:00:55.737 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######6:<type 'instancemethod'=""><br>2016-06-27 12:00:55.738 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######3:&lt;stevedore.extension.Extension object at 0x492fc50&gt;<br>2016-06-27 12:00:55.749 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######4:<class 'stevedore.extension.extension'=""><br>2016-06-27 12:00:55.750 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######5:(&lt;bound method OpenvswitchMechanismDriver.delete_subnet_pos<br>tcommit of &lt;neutron.plugins.ml2.drivers.mech_openvswitch.OpenvswitchMechanismDriver object at 0x3a42d50&gt;&gt;,)<br>2016-06-27 12:00:55.750 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######6:<type 'instancemethod'=""><br>2016-06-27 12:00:55.751 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######3:&lt;stevedore.extension.Extension object at 0x492fc50&gt;<br>2016-06-27 12:00:55.762 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######4:<class 'stevedore.extension.extension'=""><br>2016-06-27 12:00:55.763 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######5:(&lt;bound method L2populationMechanismDriver.delete_subnet_po<br>stcommit of &lt;neutron.plugins.ml2.drivers.l2pop.mech_driver.L2populationMechanismDriver object at 0x3a429d0&gt;&gt;,)<br>2016-06-27 12:00:55.763 14997 ERROR neutron.plugins.ml2.managers [req-1df986e6-3df2-4125-b555-e29ab7df384c None] #######6:<type 'instancemethod'=""></type></class></type></class></type></class></p>
<p>&lt;% endcodeblock %&gt;</p>
<p>另外一个有意思的细节是network什么时候schedule的呢，就是第一个create_port的时候，<br>Controller在收到发送port_create_end消息的时候，会调用DhcpAgentNotifyAPI的notify<br>这里的notify就很特殊处理了，不会傻乎乎的直接notify<br>如果是port_create_end消息，先做schedule，然后才发送消息。<br>也就是之前虽然有network_create_end, subnet_create_end之类的消息，基本没啥用</p>
<p>&lt;% codeblock %&gt;</p>
<pre><code># schedule the network first, if needed
schedule_required = method == &apos;port_create_end&apos;
if schedule_required:
    agents = self._schedule_network(admin_ctx, network, agents)

enabled_agents = self._get_enabled_agents(
    context, network, agents, method, payload)
for agent in enabled_agents:
    self._cast_message(
        context, method, payload, agent.host, agent.topic)
</code></pre><p>&lt;% endcodeblock %&gt;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2016/06/27/创建资源后如何通知agent/" data-id="cjuruem3b00182glom29yl3ss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/neutron/">neutron</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-emacs显示行尾空格" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/24/emacs显示行尾空格/" class="article-date">
  <time datetime="2016-06-24T08:13:01.000Z" itemprop="datePublished">2016-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/24/emacs显示行尾空格/">emacs显示行尾空格</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>emacs写python的时候，行尾的空格能显示还是很不错的，找了好几个插件,blankmode,whitespce啥的，后来发现一个简单的highlight-chars.el就能搞定。<br>主页：<a href="https://www.emacswiki.org/emacs/highlight-chars.el" target="_blank" rel="noopener">https://www.emacswiki.org/emacs/highlight-chars.el</a><br>.emacs里添加<br><code><br>(require ‘highlight-chars)<br>(hc-toggle-highlight-trailing-whitespace)<br></code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://abonege.github.io/2016/06/24/emacs显示行尾空格/" data-id="cjuruem22000a2glokv4szb5z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/emacs/">emacs</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CC防护/">CC防护</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RSA加密/">RSA加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RegEx/">RegEx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSL/">SSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/emacs/">emacs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flow-table/">flow-table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo使用/">hexo使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperscan/">hyperscan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hyperscan编译/">hyperscan编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/intel/">intel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/neutron/">neutron</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openvswitch/">openvswitch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ovs/">ovs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/resolve/">resolve</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reuseport/">reuseport</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/server/">server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/upstream/">upstream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字节序/">字节序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安全组/">安全组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/封禁/">封禁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游记/">游记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络字节序，主机字节序/">网络字节序，主机字节序</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CC防护/" style="font-size: 10px;">CC防护</a> <a href="/tags/RSA加密/" style="font-size: 10px;">RSA加密</a> <a href="/tags/RegEx/" style="font-size: 10px;">RegEx</a> <a href="/tags/SSL/" style="font-size: 10px;">SSL</a> <a href="/tags/emacs/" style="font-size: 10px;">emacs</a> <a href="/tags/flow-table/" style="font-size: 10px;">flow-table</a> <a href="/tags/hexo使用/" style="font-size: 10px;">hexo使用</a> <a href="/tags/hyperscan/" style="font-size: 10px;">hyperscan</a> <a href="/tags/hyperscan编译/" style="font-size: 10px;">hyperscan编译</a> <a href="/tags/intel/" style="font-size: 10px;">intel</a> <a href="/tags/neutron/" style="font-size: 15px;">neutron</a> <a href="/tags/nginx/" style="font-size: 20px;">nginx</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/openvswitch/" style="font-size: 10px;">openvswitch</a> <a href="/tags/ovs/" style="font-size: 10px;">ovs</a> <a href="/tags/resolve/" style="font-size: 10px;">resolve</a> <a href="/tags/reuseport/" style="font-size: 10px;">reuseport</a> <a href="/tags/server/" style="font-size: 10px;">server</a> <a href="/tags/upstream/" style="font-size: 10px;">upstream</a> <a href="/tags/字节序/" style="font-size: 10px;">字节序</a> <a href="/tags/安全组/" style="font-size: 10px;">安全组</a> <a href="/tags/封禁/" style="font-size: 10px;">封禁</a> <a href="/tags/游记/" style="font-size: 10px;">游记</a> <a href="/tags/网络字节序，主机字节序/" style="font-size: 10px;">网络字节序，主机字节序</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/22/关于在nginx上实现dyserver的思路/">关于在nginx上实现dyserver的思路</a>
          </li>
        
          <li>
            <a href="/2019/04/19/一起理解nginx的监听流程/">一起理解nginx的监听流程</a>
          </li>
        
          <li>
            <a href="/2018/04/26/理解字节序/">理解字节序</a>
          </li>
        
          <li>
            <a href="/2018/02/14/a-out的幕后/">a.out的幕后</a>
          </li>
        
          <li>
            <a href="/2018/01/31/RSA算法证明/">RSA算法证明</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 abonege<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>